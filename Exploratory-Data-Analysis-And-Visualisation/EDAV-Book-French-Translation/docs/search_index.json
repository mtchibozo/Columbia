[
["index.html", "edav.info/ Bienvenue 0.1 Tout ce dont vous aurez besoin pour Exploratory Data Analysis &amp; Visualization 0.2 Contact 0.3 License 0.4 Colophon", " edav.info/ Zach Bogart, Joyce Robbins Translated by Amaury Sudrie, Maxime Tchibozo, Romane Goldmuntz and Vy Tran 2019-10-31 Bienvenue 0.1 Tout ce dont vous aurez besoin pour Exploratory Data Analysis &amp; Visualization Cette ressource a tout ce dont vous aurez besoin pour réussir avec R, dans le cours d’EDAV et plus encore. Vous êtes prêt ? C’est parti ! L’objectif de cette ressource est de vous fournir un collection exhaustive d’outils et réferences qui faciliteront votre apprentissage du maniement de données avec R. En outre, nous avons une section sur les graphiques et outils basiques qui vous permettront d’apprendre en pratiquant. Il y a également quelques revues détaillées où nous travaillerons sur données, resolverons des problèmes et vous donnerons quelques trucs et astuces. On espères que cette ressource vous satisfera !! Cette ressource est spécialement conçue pour le cours GR5702 Exploratory Data Analysis and Visualization offert à Columbia University. Nonobstant, n’importe qui d’interressé par R peut profiter de ces quelques pages et tutoriels. Bon codage ! 0.2 Contact Zach Bogart: Site Web / Twitter / GitHub Joyce Robbins: Profil Columbia / GitHub 0.3 License This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. 0.4 Colophon Le logo de EDAV, les bannières url/404 et les icônes des chapitres associés ont été disgnés par Zach Bogart et publié sous sa permission. L’url et les bannières 404 ont été adapté pour la police Koji. Les icônes de chapitre peuvent être trouvées et achetées sur The Noun Project. Merci de rendre crédit au créateur si vous les utilisez sur des ressources extérieures (voir leur directive d’attribution des icônes pour plus d’information). "],
["intro.html", "1 Introduction 1.1 Avant-propos 1.2 Types d’assistance 1.3 Aider à améliorer edav.info/ 1.4 Fun stuff 1.5 Acknowledgments", " 1 Introduction 1.1 Avant-propos Dans ce chapitre, vous trouverez comment le site est organisé, comment vous pouvez y ajouter des contenus et enfin quelques remerciements. 1.2 Types d’assistance Chaque chapitre respecte un code couleur indiquant quel type d’assistance un chapitre vous apportera. Ci-dessous vous trouverez une explication détaillée de chaque type. 1.2.1 Information (Bleu) Les pages bleus contiennent des informations basiques. A titre d’exemple cette page et la page basics page sont des pages bleues. Cette dernière vous aidera à installer R/Studio ainsi que comment obtenir de l’aide si vous en avez besoin. Les pages bleues sont un peu le centre d’assistance de ce site : jetez y un oeil si vous vous sentez perdus. 1.2.2 Revue détaillée (Rouge) Les pages rouges contiennent des revues plus détaillées. Vous trouverez un exemple de page sur iris walkthrough. Elle présente un jeu de données très connus à travers un joli nuage de points et vous guidera du début à la fin pour le réaliser vous même. Ce type de page est très complet et a pour objectif de fournir une documentation exhaustive, des explications sur les choix esthétiques ainsi que des conseils sur les bonnes pratiques. C’est comment aller en “office hours” et obtenir des calrifications de la part d’un TA… en mode d’article. Si vous souhaitez voir voir des tutoriels complets avec un maximum de conseils tout du long, jetez un oeil aux pages rouges. 1.2.3 Documentation (Vert) Les pages vertes contiennent des documentations plus compactes. A titre d’exemple la page histogram page est verte et inclue des exemples simple d’histogrammes, quand les utilisez et les choses auxquelles il faut faire attention. Les pages vertes vous prendront beaucoup moins par la main que les pages rouges : elles vous expliqueron comment utiliser un graphique ou outil à l’aide d’exemples et de termes simples. Si vous avez une idée en tête et que vous vous demandez simplement comment l’exécuter, les pages vertes vous aideront à le faire. 1.2.4 References (Yellow) Les pages jaunes contiennent des collections de references. A titre d’exemple vous pouvez consultez external resources page qui liste différents materiels et contenus intéressant que vous pourrez étudier. Les pages jaunes ne vous aideront pas en tant que tel, il s’agit seulement de collections de ressources et de tutoriels minimalistes qui vous permettront d’explorer et d’apprendre de nouvelles choses. 1.3 Aider à améliorer edav.info/ Ce site est une ressource évolutive par les étudiants pour les étudiants, vous êtes inviter à aider à l’améliorer. Vous ne trouvez pas ce que vous chercher ? Vous pensez qu’une section pourrait être plus claire ? N’hésitez pas à aider edav.info/ en soumettant une pull request sur le github. Je ne comprends pas cette dernière phrase ? Jetes un oeil à Comment contribuer à edav.info/. 1.4 Fun stuff 1.4.1 T-shirts Zach Bogart a fait quelques t-shirt disponible sur Teespring ainsi vous pourrez montrer votre amour pour EDAV et R. Nous éspérons que vous aimerez !! 1.5 Acknowledgments 1.5.1 Our Contributors Un grand merci à tous ceux qui ont contribué de prêt ou de loin.. Vous avez rendu edav.info/ possible. Aashna Kanuga (@aashnakanuga), @Akanksha1Raj, Akhil Punia (@AkhilPunia), Akshata Patel (@akshatapatel), Angela Li (@angela-li), @anipin, @AshwinJay101, Eric Boxer (@Ecboxer), @excited-student, @hao871563506, Harin Sanghirun (@harin), @jw2531, @kiransaini, @leahparreztnik, Louis Massera (@louismassera), @naotominakawa, Neha Saraf (@nehasaraf1994), Oleh Dubno (@odubno), Ramy Jaber (@ramyij), Rod Bogart (@rodbogart), @Somendratripathi, Tim Kartawijaya (@TimKartawijaya), @ujjwal95, Zhida Zhang (@ZhangZhida) "],
["basics.html", "2 Les bases de R 2.1 Top 10 2.2 Dépannage 2.3 Astuces et tours de passe-passe 2.4 Rendu de devoirs 2.5 Demander de l’aide", " 2 Les bases de R Donc… Il y a tellement de choses qui peuplent le monde de R. Des livres, des astuces, des exercices, et plus d’autres buzzwords plein de ressources que vous pouvez parcourir. Il y a plus de 15100 packages sur CRAN, le réseau au travers duquel le code R et ses packages sont distribués. Cela peut sembler écrasant mais pour autant, gardez à l’esprit que R est utilisé pour beaucoup de chose, et toutes ne sont pas nécessaires dans le cadre de EDAV. Dans un effort de garder tout le monde au même niveau, voici une liste d’éléments essentiels de sorte que vous serez paré pour ce cours. Les meilleures ressources sont disséminées en différents endroits, en ligne, donc parcourez les liens des divers sites web en fonction des sujets. 2.1 Top 10 (r4ds = R for Data Science par Garrett Grolemund et Hadley Wickham, disponible gratuitement en ligne) Installez R (r4ds) – Vous devez installer ceci, mais vous n’aurez pas à ouvrir l’application puisque vous travaillerez avec RStudio. Si vous avez déjà installé R, vérifiez que vous êtes à jour! La dernière version (à ce jour 2019-10-31) est R 3.6.1 “Action of the Toes” released on 2019/07/05. Installez RStudio (r4ds) – Téléchargez la version gratuite, Desktop pour votre système d’exploitation. Travailler avec cet environnement rendra R beaucoup plus agréable. Comme avec R, restez à jour. RStudio ajoute en permanence de nouvelles fonctionnalités. La dernière version (à ce jour 2019-10-31) est 1.2.5001. Devenez à l’aise avec RStudio – Dans ce chapitre du livre de Bruno Rodriquez Modern R with the Tidyverse, vous apprendrez comment utiliser des panneaux, les options, comment demander de l’aide, les raccourcis clavier, les projets, les ajouts, et les packages. Essayez: De faire des maths dans la console De créer un fichier R Markdown (.Rmd) et affichez le en .html Installez des packages comme tidyverse ou MASS Une autre bonne ressource pour apprendre à maîtriser l’environnement (IDE): Regardez Ecrire du code avec RStudio (RStudio webinar) Apprenez “R Nuts and Bolts” – Le chapitre du livre de Roger Peng R Programming vous donnera des bases solides avec les concepts fondamentaux de R. Ca vaut le coup de prendre le temps de maîtriser les objets R et comprendre comment ils fonctionnent maintenant, ça vous évitera des erreurs plus tard. Concentrez-vous sur les vecteurs et particulièrement les data frames; les matrices et listes n’apparaîssent pas souvent en data visualization. Familiarisez-vous avec les classes R: integer, numeric, character, et logical. Comprenez comment les factors fonctionnent; ils seront important pour vos futurs graphiques. Apprenez le RMarkdown – Pour ce cours, vous rendrez des devoirs sous format R Markdown (enregistrés en tant que fichiers .Rmd) et vous les afficherez sous format pdf pour la soumission. Vous pouvez essayer dès maintenant d’ouvrir un nouveau fichier R Markdown (File &gt; New File &gt; R Markdown…), et laissez le Default Output Format en HTML. Vous aurez un template R Markdown avec lequel vous pourrez faire joujou. Cliquez sur le bouton “knit” et voyez ce qui se passe. Pour plus de détails, regardez le webinar RStudio Getting Started with R Markdown Nettoyez (r4ds) – Installez le tidyverse, et familiarisez-vous avec. Nous expliquerons les différences entre R de base et le tidyverse en cours. Apprenez les bases de ggplot2 (r4ds) – En classe nous étudierons la grammaire des graphiques sur laquelle est fondée ggplot2, mais cela vous aidera à vous familiariser avec la syntaxe en avance. Préparez-vous avec la fiche “Data Visualization with ggplot2” en cliquant sur “Help” puis “Cheatsheets…” dans RStudio. Utilisez les projets RStudio (r4ds) – Si vous ne l’avez pas déjà fait, sirotez un verre de grenadine. Faites un projet pour chaque problème différent. Vous n’aurez jamais à vous soucier avec getwd() ou setwd() puisque tout sera déjà au bon endroit. Ou regardez le webinar: “Projects in RStudio” Apprenez les verbes élémentaires de dplyr pour la manipulation de données (r4ds) – Concentrez-vous sur les verbes principaux: filter() (lignes), select() (colonnes), mutate(), arrange() (lignes), group_by(), et summarize(). Apprenez à utiliser l’opérateur pipe %&gt;%. Sachez comment nettoyer vos données – La fonction gather() du package tidyr vous aidera à formatter vos données pour les graphiques. Nous en reparlerons en cours. Regardez ces annimations super cool, qui suivent la transformation d’un data frame par les fonctions de tidyr. Conseils généraux: ne vous souciez pas des détails. Gardez une liste de questions et avancez. 2.2 Dépannage 2.2.1 Mon document ne se visualise pas correctement quand j’utilise “knit” Cliquez sur “Session” “Restart R” puis exécutez les blocs un par un jusqu’à ce que vous trouviez l’erreur. 2.2.2 Les fonctions ne marchent plus Le comportement étrange de fonctions qui fonctionnaient bien avant sont souvent causés par des conflits de fonctions. Ceci peut se passer quand vous avez deux packages chargés avec les mêmes noms de fonctions. Pour indiquer le bon package, utilisez namespace. Les conflits ont souvent lieu avec select, filter et map. Si vous voulez utiliser les fonctions tidyverse, utilisez: dplyr::select, dplyr::filter and purrr::map. Vous avez d’autres conflits ou problèmes? Publiez une issue. 2.3 Astuces et tours de passe-passe 2.3.1 Knitr Montez en puissance avec vos options de bloc: vérifiez la liste officielle des options – and annotez-là! Quelques classiques: warning=FALSE message=FALSE – utile quand vous chargez des packages cache=TRUE – évaluera uniquement les blocs modifiés, mais faîtes attention, les changements de dependencies ne seront plus détectées. fig.… options, voir ci-dessous 2.3.2 Raccourcis clavier RStudio option-command-i (“Insérez un bloc R”) ```{r} ``` shift-command-M %&gt;% (“pipe”) 2.3.3 Taille des figures (et bien plus encore) Utilisez toujours les paramètres de blocs pour les tailles de graphiques. Vous pouvez définir une taille par défaut dans le YAML au début du fichier .Rmd comme ci-dessous: output: pdf_document: fig_height: 3 fig_width: 5 Une autre méthode consiste à cliquer sur l’engrenage ⚙️ à côté du bouton Knit, puis Output Options…, et finalement l’onglet Figures. Puis outrepassez les paramètres par défaut de blocs particuliers: {r, fig.width=4, fig.height=2} Les options de blocs liées aux figures (graphiques) sont fig.width, fig.height, fig.asp, et fig.align; il y en a beaucoup d’autres. 2.3.4 Visualiser des graphiques dans des fenêtres pour graphique Vous souhaitez que vos graphiques apparaîssent dans la fenêtre d’affichage plutôt que sous chaque bloc du fichier .Rmd ? Cliquez sur ⚙️ puis Chunk Output in Console. 2.4 Rendu de devoirs Voici un petit topo sur comment soumettre vos devoirs en utilisant R Markdown et Knitr. Creez un fichier R Markdown avec en sortie un format PDF: Nous vous donnerons souvent un template, libre à vous de le modifier directement, mais assurez-vous que le format de sortie est bien pdf_document. Ecrivez toutes vos explications puis ajoutez des blocs de code pour répondre aux questions. Si vous voulez faire un nouveau fichier, allez dans File &gt; New File &gt; R Markdown… et définissez le Default Output Format comme PDF. Quoi qu’il en soit, l’en-tête d’un fichier .Rmd doit ressembler à ceci: Ajoutez des dépendances PDF: Comme indiqué quand vous commencez un nouveau fichier R Markdown, le PDF de sortie nécessite TeX: Assurez-vous d’avoir téléchargé Tex pour votre machine. Voici quelques articles Medium sur comment créer des rapports en PDF: Mac OS Windows C’est un peu compliqué, mais cela fera en sorte que le bouton Knit en haut de l’IDE génerera un PDF comme par magie. Si vous êtes débordé et souhaitez un raccourci, vous pouvez définir le Default Output Format comme HTML. Quand vous ouvrez le fichier dans votre navigateur, vous pouvez l’enregistrer en PDF. Il ne sera pas aussi bien formaté, mais ça devrait marcher. 2.5 Demander de l’aide via https://dev.to/rly Déjà …caaaaaalme. On peut réparer ça. Il y a un tas de ressources à votre disposition. 2.5.1 Choses à essayer Souvenez-vous: Aidez-vous vous-même! Cet article a une bonne liste d’outils pour vous aider à en apprendre plus sur quelquechose que vous ne comprenez pas. Ceci inclut l’apprentissage des fonctions et packages, tout comme la recherche d’informations sur une fonction/package/problème/etc. C’est l’endroit idéal pour apprendre à trouver l’info que vous cherchez. Le menu Help de RStudio (dans la barre d’outils du haut) est un outil fantastique pour comprendre/réparer n’importe quel problème. Il y a des liens vers la documentation et des manuels ainsi que des fiches et une belle collection de raccourcis clavier. Les vignettes sont un super moyen d’en apprendre plus sur les packages et leur fonctionnement. Le vignettes sont comme des des manuels stylisés qui illustrent mieux le contenu d’un package. Par exemple, ggplot2 a une vignette sur les aesthetics appellée ggplot2-specs qui parle des différentes façons d’afficher les données sous différents formats. Taper browseVignettes() dans la console vous montrera toutes les vignettes pour tous les packages que vous avez installés. Vous pouvez aussi voir des vignettes par package en tapant vignette(package = &quot;&lt;package_name&gt;&quot;) dans la console. Pour exécuter une vignette spécifique, utilisez vignette(&quot;&lt;vignette_name&gt;&quot;). Si cela ne fonctionne pas, incluez le nom de package aussi : vignette(&quot;&lt;vignette_name&quot;, package = &quot;&lt;package_name&gt;&quot;) N’ignorez pas les erreurs. Elles vous en disent beaucoup! Si vous abandonnez dès que du texte rouge apparaît dans votre console, prenez le temps de voir ce que le texte rouge dit . Apprenez Comment lire des erreurs et ce qu’elles vous disent. En général elles incluent le lieu d’apparition et la source du problème. Plus avancé: Apprenez à aimer le mode deboggage. Il y a une grande courbe d’apprentissage, mais ça vaut le coup. Regardez ces vidéos sur debogger avec R. Les thèmes incluent l’exécution du deboggueur, la mise en place de breakpoints, la customization des preferences, et plus encore. Note: Les fichiers R Markdown sont limités en terme de deboggage, comme expliqué dans cet article. Vous pouvez aussi considérer de travailler dans un fichier .R avant de l’inclure dans votre devoir en R Markdown . 2.5.2 A l’aide! Du calme. Il y a un tas de personnes qui utilisent les mêmes outils que vous. Vos camarades sont un bon point de départ! Postez vos questions sur Piazza pour voir comment ils pourraient vous aider. Il y a beaucoup de bonnes documentations sur R et ses fonctions/packages/etc. Devenez pro avec la Documentation R. Il y a une communauté vivante! RStudio Community page. Aussi, R aime twitter. Regardez #rstats ou encore Prevenez Hadley Wickham quand vous recevez un message d’erreur bizarre. "],
["project.html", "3 Final Project Assignment 3.1 Vue d’ensemble 3.2 Info Generale 3.3 Format du rapport 3.4 Schéma 3.5 Style de presentation 3.6 Grading 3.7 Resources", " 3 Final Project Assignment 3.1 Vue d’ensemble Cette section couvre ce qui est attendu pour le projet final Spring 2019. Note Generale: Remarquez que cette doc ne peut pas couvrir l’ensemble des règles et principes d’EDAV. Nous esperons que vous suivrez toutes les consignes et bonnes pratiques vues en classe. 3.2 Info Generale 3.2.1 Objectif L’objectif de ce projet est d’explorer et analyser des données / créer des visualizations avec les données de vos choix dans le but d’étendre vos connaissances sur des sujets qui vous intéressent directement. ### Equipes Pour ce projet vous devrez travailler en équipes de 2. Si vous souhaitez choisir votre partenaire, faites-le avant Jeudi 28 Mars, 2019. Piazza est une bonne ressource pour montrer vos centres d’intérêts et trouver des partenares. Après le 28 Mars, des partenaires seront assignés de manière aléatoire. (Ce qui est bien pour vous préparer à travailler dans un environnement avec des collègues que vous ne connaissez pas bien.) Si vous avez déjà un partenaire et souhaitez commencer avant la date limite (ce qui est encouragé), envoye-moi un email. Une fois que le partenaire est assigné, glissez vos noms dans un des groupes déjà créés avec le nom “Final Project ” dans la rubrique People de Courseworks. Ne cliquez pas sur le bouton +Group. (Si vous ne suivez pas ces instructions et que vous créez votre propre groupe, il ne sera pas lié au rendu de projet final, et vous ne pourrez pas soumettre votre projet correctement.) Une fois les groupes créés, nous vous demanderons une petite description de vos idéez, commmencez à vous préparer dès maintenant! 3.2.2 Sujets Le choix du sujet est libre… choisissez quelquechose qui vous intéresse directement et qui attise votre curiosité! Pensez à des questions auxquelles vous ne connaissez pas la réponse. Puis cherchez les données qui vous aideraient à répondre à ces questions. 3.2.3 Données Les données peuvent venir de sources différentes; elles ne doivent pas nécessairement venir du même jeu de données. Par exemple, si vous souhaitez travailler avec des données collectées et distribuées par le Centers for Disease Control, c’est ici que vous devrez obtenir les données, et pas par un parti tiers qui a posté des données. Evitez les jeux de données classiques (i.e Titanic) et ceux qui sont utilisez sur Kaggle (ou d’autres competitions). 3.2.4 Code Votre code devrait être sur GitHub. Nous allons passer du temps en classe pour apprendre comment utiliser Git/GitHub, mais vous êtes libres de choisir comment vous le faîtes. Faites que votre projet soit organisé. Au minimum, créez un dossier data/raw (avec peut-être .gitignore), un dossier data/tidy (ou alors un autre nom qui montre que vous avez déjà travaillé sur les données… il ne doit pas forcément être propre), et un dossier analysis pour vos fichiers .Rmd et .html (output). Vous pouvez aussi avoir un dossierR pour preprocesser les scripts ou functions qui ne sont pas dans le fichier .Rmd. Dans votre rapport, mettez un lien vers le repo, et des liens vers les fichiers spécifiques qui vous semblent importants. Les visualisations statiques devront être faîtes en R, mais pas les autres ressources (i.e données importées et/ou nettoyées). 3.2.5 Analyse Vous êtes libres pour le choix de ce que vous utilisez, tant que vous vous contraignez aux techniques d’exploration (plutôt que de modélisation/prédiction). Par ailleurs, votre analyse doit être documentée clairement, proprement, et doit pouvoir être reproduite. 3.2.6 Feedback Vous pouvez à tout moment demander conseil aux TA ou à l’instructrice (Joyce). Notre rôle principal sera de vous guider dans votre approche et dans votre choix de données / sujet / direction. Comme toujours, vous pouvez poser vos questions sur Piazza, particulièrement pour ce qui est des questions de code ou de problèmes techniques. Vous pouvez aussi vous dévouer pour parler de votre projet à la classe entière pour récupérer des avis–si vous souhaitez faire ceci, emailez l’instructrice pour choisir une date. 3.2.7 Examen par des pairs Après avoir rendu vos projets finaux, on vous demandera d’écrite des “peer reviews” des autres projets. Chaque personne devra faire une critique de deux sujets, et des instructions vous seront données. Note: une partie de la note que vous recevrez pour ce cours est basée sur la qualité de la critique que vous apportez, pas sur les critques que votre projet reçoit. Vos notes pour le projet seront uniquement déterminées par l’instructrice et les TA (comme c’est le cas pour les autres devoirs). 3.3 Format du rapport Le rapport devrait faire à peu près 15 pages avec graphiques, sans code. A peu près pages pour les parties I.-IV. et 10 pages pour les parties V.-VII. Vous pouvez vérifier le nombre de pages en regardant l’aperçu avant impression du navigateur. Tous les graphiques doivent être accompagnés d’une description/interprétation en texte. Vous devrez certainement produire plus de graphiques que vous avez de place dans votre rapport. Vous garderez ceux-ci dans des fichiers sur GitHub, et vous les lierez au rapport si ils sont utiles/ A l’exception de la partie interactive, votre projet devra être rendu via CourseWorks sour format .Rmd et .html, avec graphiques / output knitté. Le format de sortie dans le YAML devrait être: output: html_document: code_folding: hide Ce format permet aux utilisateurs de choisir s’ils veulent voir le code ou non. Il y aura certainement des parties de votre projet que vous ne pourrez pas inclure dans les fichier .Rmd / .html . Dans ces cas, vous devrez poster vos ressourecs en ligne et mettre des liens dans votre rapport pour y accéder. Cela vaut particulièrement pour la partie graphiques interactifs. Vous perdrez des points si nous avons du mal à lire votre fichier, que nous avons à vous redemander de publier les graphiques visibles, si les liens sont cassés, ou que nous avons du mal à accéder à votre travail. C’est ok si le code est dans des fichiers différents, tant que vous avez des liens qui fonctionnent dans votre rapport pour y accéder. Note: L’utilisation de Markdown + blocs de code est supposée faciliter la combinaison de code, texte et graphiques. Si ce n’est pas le cas, c’est que vous êtes sans doute en train d’utiliser le mauvais outil. Concentrez-vous sur les textes et graphiques, pas le formattage. Si vous n’êtes pas sûr de si quelquechose est important ou non, demandez-nous. Conseil: n’attendez pas avant de commencer à écrire. Votre projet général sera certainement mieux si vous arrêtez d’essayer d’avoir le graphique parfait et que vous vous mettez à écrire! Vous êtes encouragés à être le plus honête possible. Si il y a des défauts dans votre travail, des obstacles de taille, des désaccords, des choix importants, etc. – le genre de chose que se passe en “behind-the-scene” ou autres choses importantes mais qui n’apparaissent pas dans les rapports. Vous pouvez utiliser la première personne (“I”/“We”) ou mentionner directement le nom de votre partenaire si besoin. 3.4 Schéma Votre rapport doit contenir les sections suivantes, avec en-tête (“I. Introduction”, etc.) comme suit: I. Introduction Expliquez pourquoi vous avez choisi ce sujet, et les questions qui vous intéressent. Donnez un contexte pour les lecteurs qui ne connaissent pas ce sujet. II. Description des données et de leur source Décrivez la source des données: qui est responsable de la collecte de ces données? Comment ont-elles été collectées? Si vous aviez le choix, expliquez comment vous choisisseriez. Donnez quelques données élémentaires sur le dataset: type des variables, quantité de données, etc. Décrivez tout problème lié aux données. (Vous devriez pouvoir écrire cette rubrique avant même d’avoir travaillé avec les données.) III. Description des données importées / nettoyées / transformées Decrivez le processus que vous avez suivi pour mettre en forme les données pour le R. IV. Analyse des données manquantes Décrivez les éventuelles répétitions ou motifs que vous observez avec les données manquantes. V. Resultats Donnez un bref résumé non technique des trouvailles les plus importantes de votre recherche - ce résumé doit être écrit pour un public non-technique. Faites bien attention à nettoyer vos graphiques, vous assurer que les meilleures pratiques pour la présentation ont été suivies, comme décrit dans la rubrique présentation ci-dessous. Note: “Presentation” fait ici référence au style des graphiques, i.e graphiques qui ont été nettoyés pour la présentation, par opposition aux graphiques bruts qu’on utilis souvent en exploration de données. Vous n’avez pas à présenter votre travail à toute la classe! VI. Partie Interactive Selectionnez une (ou plusieures) observations-clés et présentez-les de façon interactive. Soyez selectifs dans les choix que vous présentez à l’utilisateur; l’idée est qu’il puisse comprendre les questions que vous vous êtes posés et les tendances que vous avez découvertes en 5-10 minutes. En d’autres termes, ils devraient comprendre la valeur de votre analyse, d’un point de vue économoique, scientifique, en terme de compétence générale, etc. Les graphiques interactifs doivent suivre toutes les bonnes pratiques, tout comme les graphiques statiques pour ce qui est de la perception, l’étiquettge, la justesse, etc. Vous pouvez choisir l’outil (D3, Shiny, ou autre) La complexité de votre outil sera prise en compte: nous attendons plus de complexité d’un outil de haut-niveau comme Shiny que d’un outil de bas niveau comme D3, où c’est à vous de tout construire. Assurez-vous que l’utilisateur comprend bien l’outil et comment l’utiliser. Publiez votre graphique quelquepart sur internet et mettez un lien dans votre rapport vers cette partie interactive. Les choix évidents sont blockbuilder.org pour créer un bloc pour D3, et shinyapps.io pour les applis Shiny, mais d’autres options marchent aussi. Vous êtes encouragés à partager votre retour d’expérience sur Piazza pour aider vos camarades. Notez: la partie interactive compte pour à pau près 25% de la note finale du projet. Ne passez pas 90% de votre temps dessus… concentrez-vous sur la partie exploration et analyse de données. VII. Conclusion Discutez des limitations et perspectives, des lessons apprises. 3.5 Style de presentation Comme indiqué pendant l’année, on attend plus de vous pour des graphiques qui doivent être partagés avec d’autres personnes. En EDAV général, on se contente du minimum, mais vous devrez faire de votre mieux pour la présentation ici. Voici une checklist d’outils destinés à perfectionner vos graphiques (et les rendre présentables). (Ne vous souciez pas de ces prooblèmes pour la partie EDA.) Titre, étiquettes des axes, étiquettes de graduation, légendes doivent être comprehensibles et lisibles. Les etiquettes de graduation ne devraient pas être étiquetées en notation scientifique ou avec beaucoup de zéros, comme 3000000000. Convertissez-les en chiffres plus petits et changez les unités: 3000000000 devient “3” quand l’étiquette de l’axe est “milliards de vues”. Les unités devraient être intuitives (Un axe étiqueté mois/jour/an format is intuitif; un axe étiquetté en secondes depuis le 1er Janvier, 1970 ne l’est pas.) L’épaisseur de la police doit la rendre lisible. Le ggplot par défaut est trop petit. Vous pouvez facilement le changer en passant la police de base comme celle du thème, en faisaint par exemple + theme_grey(16) (La police par défaut est 11). L’ordre des objets sur les axes et les légendes doivent être logiques (l’ordre alphabétique n’est pas toujours bon.). Les couleurs doivent pouvoir être vues par des daltoniens. Si les niveaux de données catégoriques sont longs, faîtes que la variable catégorique soit sur l’axe des y et les noms soient horizontaux. Une meilleure option, si possible, est de raccourcir le nom des niveaux. Pas tous les graphiques EDA se prêtent à la présentation, soit parce qu’ils sont trop compliqués à comprendre ou parce qu’ils ne permettent pas un étiquettage clair. Le problème d’étiquettage peut être résolu en ajoutant du texte dans un éditeur d’image. Le bémol est que ce n’est plus reproduisible. Si vous choisissez cette option, pour Mac, Keynote et Paintbrush sont de bonnes options gratuites. Faîtes au plus simple. Evitez les couleurs quand elles ne sont pas nécessaires. Demandez-vous : la couleur rend-elle ce graphique plus claire? Si non, n’en mettez pas. Testez vos graphiques avec des amis non-techniques, et demandez du feedback à vos amis/famille. Avant tout, amusez-vous 3.6 Grading Nous préférons ma qualité plutôt que la quantité Pour déterminer vos notes, nous regardons: Originalité Vos questions font-elles réfléchir? Encouragent-elle le lecteur à voir le sujet sous un nouvel angle? Contexte Vos graphiques et descriptions textuelles reflètent-elles une bonne compréhension du sens de vos données? Est-ce que le pourquoi est clair? Vos interprétations sont-elles raisonables? Reproductibilité Avez-vous rendu votre code clair pour le lecteur, et facile à exécuter pour qu’il retrace votre analyse? Avez vous inclu des explications pour ce qui ne peut pas être reproduit? Le code est-il clair? Multidimensionnalité Avez vous bien étudié les relations multidimensionnelles? Choix de formes graphiques Vos graphiques sont-ils bien choisis par rapport à vos données. Paramètres / choix de design Avez-vous bien choisi vos paramètres, couleurs, etc.? Standards Faîtes que vos graphiques vérifiernt les normes stylistiques de presentation? Partie interactive La partie interactive se lie-t-elle bien aux objectifs du projet? Est-elle utile aux objectifs du projet? Aide-t-elle le lecteur à comprendre les conclusions principales? 3.7 Resources “Tidy Tuesday Screencast: analyzing college major &amp; income data in R” David Robinson explores a dataset in R live, without looking at the data in advance. This may be helpful in figuring out how to get started. "],
["contribute.html", "4 Contribuez à cette ressour e 4.1 Pourquoi contribuer? 4.2 Que contribuer? 4.3 Comment contribuer 4.4 Soumettez une “issue” 4.5 Tutoriel GitHub 4.6 Ressources", " 4 Contribuez à cette ressour e 4.1 Pourquoi contribuer? Nous ne voulons pas qu’edav.info/ devienne juste une autre ressource. Nous voulons qu’edav.info devienne votre ressource. Si vous bloquez sur quelquechose, il y a de grandes chances que vous ne soyez pas seul. Tout le monde commence ce cours avec un parcours et des compétences différentes. L’objectif de cette ressource est de collecter toutes ces connaissances et de les regrouper au même endroit, et vous pouvez nous aider à réaliser cette mission. 4.2 Que contribuer? L’intérêt premier de edav.info est d’étudier l’aspect “programmation” de la data visualization avec R. Edav.info n’a pas vocation à être un substitut pour le cours, ou d’étudier la théorie de l’analyse de données et la visualisation. Nous voulons tout simplement permettre aux étudiants de trouver ce qu’ils cherchent quand ils veulent créer un certain type de graphique vite. Nous sommes ouvert à différents types de contributions, mais nous avons quelques règles: Nous acceptons volontiers des travaux originaux qui aideront les élèves. Par exemple, si vous avez compris comment utiliser une fonction mal documentée, ou que vous avez maîtrisé un certain type de graphique difficile à comprendre, partagez ces informations! Néanmoins, si un bon manuel existe quelque part, ça ne sert à rien de répéter le travail. Donnez-nous juste un lien vers la ressource avec une petite description. Et bien entendu, n’oubliez jamais de citer vos sources en donnant des liens. 4.3 Comment contribuer Il y a beaucoup de manières de contribuer: Pour des grandes ou petites idées, sans écrire de code Soumettez une “issue” (très simple, bien apprécié) Pour des changements simples contribuez sur GitHub (ceci peut être fait sur GitHub.com… nous avons un tutoriel qui explique comment faire) Pour des changements plus complexes installez Git et travaillez localement. Des instructions détaillées sont sur notre Git/GitHub chapitre Ressources (le niveau au-dessus, aussi bien apprécié) – les utilisateurs les plus aventureux pourront résoudre une “issue” non-resolue (plus avancé/ouvert) 4.4 Soumettez une “issue” Si le changement que vous voulez faire est compliqué, prévenez-nous en soumettant une “issue” . Vous avez peut-être une super idée pour un nouveau chapitre, quelquechose que nous n’avons pas couvert, mais que vous aimeriez voir présent ici dans cette ressource (une nouvelle page sur un graphique; un tutoriel pour utiliser un outil/package particulier). Il peut être un peu trop compliqué de contribuer directement. La solution? Soumettez une “issue” bien entendu! Les “issues” sont des tâches que vous pouvez poster sur un dépôt GitHub et que d’autres personnes peuvent tenter de résoudre? Elles peuvent être petites (“ce lien est cassé”/“ajoutez cette ressource”) ou complexes (“J’aimerais proposer un chapitre sur …” / “Il faut reformater ce bloc de code de cette façon”). Une fois postée l’issue peut être traitée par n’importe qui. Vous n’avez pas à savoir coder pour soumettre votre issue; corriger un bug tout comme proposer une nouvelle ressource que nous devrions mentionnes, nous apprécions tout retour que vous puissiez avoir. Comment soumetre des “issues”: Allez sur notre dépôt GitHub et cliquez sur l’onglet Issues Cliquez sur “New Issue” Proposez votre Issue et cliquez “Submit new issue” Ca y est! Nous apprécions votre aide, et prendrons en compte votre issue en améliorant edav.info/ Notes sur la soumission d’Issues: Vérifiez que vos changement ne sont pas déjà dans une issue existante (évitons les redondances) Veuillez explique le changement que vous proposez au moment de poster une issue Pensez à utiliser des étiquettes (labels) pour spécifier le type d’issue, telle qu’un “beug”, “une amélioration”, “un appel à l’aide”, “une question”, ou créez votre propre étiquette (label). Pour plus d’infos, veuillez lire le Guide Open Source sur comment contribuer. 4.5 Tutoriel GitHub Vous devrez créer un compte github si vous n’en avez pas encore, mais vous n’aurez pas à installer Git localement. Note: Voici un tutoriel complet qui aide un étudiant hypothétique qui vient de voir une faute et utilise une requête pull pour la corriger. Même si ces instructions sont pour le cas où vous souhaitez proposer un changement sur edav.info, elles valent pour tout changement sur n’importe quel dépôt. Naviguez sur le fichier que vous aimeriez changer, et cliquez sur le bouton stylo: Ne cliquez pas sur le bouton fork sur la page d’accueil du dépôt. Suivez l’étape 4 ci-dessous. Une manière de contribuer à edav.info est de contribuer directement en modifiant un chapitre. En haut de chaque page de cette ressource, vous trouverez une icône qui ressemble à ceci: . Cliquer dessus ouvrira un nouvel onglet ou vous pourrez editer le markdown pour cette page sur notre dépôt GitHub et soumettre votre changement avec une requête pull. En gros, vous copiez une version de notre repo, vous faites vos changements, et vous nous suggérez de les inclure. Si nous approuvons vos changements, ils apparaîtront sur edav.info . La meilleure approche pour les petits changements (faute d’orthographe, phrase peu claire) est de suivre la méthode détaillée ci-dessus. En général, changer directement le code sur GitHub ne marche pas très bien. Ok, on est bons. Préparez vous à cliquer sur beaucoup de grous bouttons verts! Unde dernière chose: n’oubliez pas que vous ne pouvez pas modifier le dépoôt de quelqu’un sans soumettre une requête pull et que le propriétaire la merge. N’ayez pas peur de faire comme si vous étiez le propriétaire et modifiez les fichiers comme vous le souhaitez. Vous éditez juste une copie des fichiers; c’est permis! Etape 1: Trouver quelquechose à changer Je suis assez sûr qu’ils voulaient écrire “repository” ici. Oups. On va corriger ça pour eux! C’est pas comme ça qu’on écrit “repository”! Corrigeons cela. Etape 2: Cliquez sur le bouton edit Pour faire ce changement, on clique sur l’icône edit, , en haut de la page. Ceci vous amènera sur leur dépôt GitHub, où on trouve tout le code pour cette ressource. Note: Vous devez avoir un compte GitHub valide pour contribuer. Dans ce cas, on utilise un faux compte appellé excited-student donc si vous voulez voir une capture d’écran, sachez que le compte serait remplacé par votre propre nom d’utilisateur. Cliquez ce bouton pour aller sur GitHub. Etape 3: Forkez le dépôt C’est notre première modification sur le dépôt, donc GitHub nous montre une page comme celle ci-dessous. Aucun soucis! On clique juste sur le gros bouton vert étiquetté Fork this repository and propose changes et on sera bons (les gros boutons verts sont nos amis). Note: vous n’aurez pas à forker à chaque fois. Si vous proposez un autre changement à l’avenir, cliquez sur l’icône edit, , vous amènera directement à cette étape du tutoriel. Vous n’avez pas encore forké le dépôt? Pas de soucis; le gros bouton vert va tout résoudre. Maintenant que nous avons forké le dépôt, nous pouvons voir le code pour la page que nous voulons éditer. Note: La petite bulle bleue en haut écrit ce qui se passe/va se passer: nous avons fait une copie du dépôt car nous n’avons pas de droit d’accès. Une fois qu’on aura fait nchangement sur cette page, nous informerons le propriétaire du dépôt quant à nos modifications en utilisant une requête Pull. GitHub peut être super troublant, mais au moins il essaie vraiment de vous informer de ce qui se passe au fur et à mesure. Prêt à modifier le code. Lisez la petite bulle bleue. Step 4: Corrigez l’erreur Corrigeons cette erreur embarrassante! Nous mettons à jour le code directement dans l’éditeur, incluez une explication de ce qu’on a changé/pourquoi on a fait ce changement, puis cliquez sur le gros bouton vert étiquetté Propose file change. J’adore ces boutons! Faîtes vos changements, incluez une petite explication, et cliquez sur le gros bouton vert. Etape 5: Comparer des changements GitHub nous aide à nouveau en nous laissant observer les changements que l’on a fait. Sur cette page on peut voir les changements proposés en allant en bas de page et regardant les diffs. Notre correction est très simple donc il n’y a pas grand chose à voir. Encore une fois, on va cliquer sur le gros bouton vert, cette fois appellé Create pull request. Ceci commencera le processus qui prévient les gens d’ edav.info/ qu’on aimerait qu’ils incluent nos changements (en parler-git, on émet une requête que les gens d’ edav.info/ fasse un git merge pour mettre à jour leur fichiers avec nos changements proposés.) Notez que les changements proposés sont dans une branche appellée patch-1 sur notre dépôt; nous leur demandons de merger dans la branche master de leur dépôt. L’occasion de voir vos changements. Une fois satisfait, cliquez sur le gros bouton vert pour soumettre une requête Pull. Etape 6: Ouvrez une requête pull Nous sommes ici en haut de la page de la requête pull. Remarquez la coche verte étiquettée “Able to merge” (un bon signe que tout marche bien). Maintenant nous expliquons notre requête pull avec quelques commentaires, et une fois de plus, cliquez sur le gros bouton vert étiquetté Create pull request. Note: Vous vous demandez peut-être, “Pourquoi est-ce que je dois encore expliquer ce que j’ai changé?”. C’est parce que l’explication écrite à l’étape 5 (où on a modifié le fichier) est un commit. Nous pouvons avoir plusieurs commits à la fois une fois que nous avons tout groupé en une requête pull. Cette étape est un moyen d’expliquer la requête pull dans sa totalité. C’est ici redondant puisque nos changements sont si petits et qu’il y a un seul commit. Toujours perdu? Ce guide GitHub pour Comrendre GitHub est vraiment utile. Notre page de Ressources GitHub contient auddi beaucoup de liens utiles. Expliquez votre requête pull et cliquez sur le gros bouton vert. Et maintenant? Félicitations ! Nous avons ouvert une requête pull sur un dépôt GitHub! Maintenant, un des propriétaires du dépôt (comme une des personnes qui écrit ce tutoriel, par exemple ) doit décider de si il/elle veut incorporer votre requête pull ou pas. Dans ce cas ils l’approuveront certainement, mais peut-être qu’ils choisissent de ne pas rajouter vos changements. Pour plus d’informations, lisez la section du Guide Open Source sur ce qui se passe quand vous soumettez une contribution. Note: Ayez en tête que l’icône ci-dessous peut être jaune pour indiquer que des changements sont en cours pour vérifier d’éventuels conflits avec votre proposition initiale. Il devrait devenir vert si tout se passe bien. On l’a fait! Maintenant les propriétaires vont voir nos changements et nous répondre… Et maintenant, on attend… via GIPHY Qu’est-ce donc!? Nous avons reçu un email d’un des propriétaires du dépôt, Zach Bogart. Il dit qu’ils ont mergé le changement! Huzzah! On clique sur le numéro pour rouvrir la requête pull qu’on avait ouverte. On a eu un email! Et il dit qu’ils ont mergé ! Cliquez ce chiffre pour voir la requête pull mise à jour. Nous sommes ici sur la page mise à jour de la requête pull. Remarquez que tout est devenu violet. Le violet est la meilleure couleur à voir sur GitHub; c’est la couleur de la victoire. Ca indique que notre pull a été mergé avec le dépôt, ce qui signifie que nos changements font partie du dépôt! Aussi, remarquez le bouton annoté Delete branch. Puisque tout le travail de notre branche est sur le dépôt, on peut l supprimer sans soucis. Tout est violet! Woot! On peut supprimer notre branche sans danger Retournons maintenant sur la page principale du dépôt. On peut voir que notre merge est l’addition la plus récente. Et si on descend, on voit que le document que nous avons édité, github_resources.Rmd, a été mis à jour récemment et montre notre messaget de commit “fix typo”. On l’a fait! Vérifions le site pour voir si nos changements on été publiés devant tout internet! Regarde! Notre requête pull a été mergé! Et nos modifications sont sur github_resources.Rmd! Ca y est! On retourne sur la page modifiée maintenant et notre correction a été inclue!Note: Les changements mettront quelques minutes à apparaître après la notification de merge résussi. C’est parce que nous utilisons Travis CI en backend de notre dépôt et que ça met un peu de temps pour republier toutes les pages du site. Si vous voulez en apprendre plus, vous pouvez utiliser Travis CI pout auto auto-magiquement générer votre travail, regardez notre section surl’utilisation de Travis avec un livre bookdown GitHub dans la page Publishing Resources. Regardez ça! C’est publié! Tellement de points d’exclamation!!! Nous avons contribué à un dépôt Git! Chapeau! Ca se fête! via GIPHY Soyons prévoyants: la prochaine modification Si vous avez un second changement à proposer, il suffit de suivre à nouveau ces instructions. Comme noté ci-dessus, la deuxième fois il ne faudra plus forker le dépôt. Si vous regardez bien la requête pull pour la deuxième modification, la branche mergée sera renommée patch-2 au lieu de patch-1. Même si GitHub parle de “votre” fork, ce n’est pas vraiment quelquechose qui vous concerne. En fait, ne vous souciez pas avec ça. Restez loin de votre fork – c’est à dire, votre copie du dépôt EDAV dans votre compte GitHub. Elle sera inevitablement en retard sur la version principale, et ça risque de causer des problèmes si vous réessayez de lancer une requête pull. Donc, chaque fois que vous avez un changement à proposer, allez directement sur edav.info ou https://github.com/jtr13/EDAV et commencez le processus d’édition là, pas sur votre fork! 4.6 Ressources Notre dépôt GitHub: Lien vers le dépôt GitHub d’ edav.info/ Guide Open Source: Un guide génial sur comment contribuer aux projets comme celui-ci "],
["histo.html", "5 Diagramme: Histogrammes 5.1 Avant-propos 5.2 tl;dr 5.3 Simple examples 5.4 Théorie 5.5 Types d’histogrammes 5.6 Paramètres 5.7 Histogramme interactif avec ggvis 5.8 Ressources externes", " 5 Diagramme: Histogrammes 5.1 Avant-propos Cette section présente comment construire un histogramme (histogram en anglais). 5.2 tl;dr Donnes-moi un véritable exemple ! Voici une application d’histogrammes qui montre comment les becs des pinsons des Galápagos ont changé enfonction de facteurs externes : Et voici le code : library(Sleuth3) # data library(ggplot2) # plotting # load data finches &lt;- Sleuth3::case0201 # finch histograms by year with overlayed density curves ggplot(finches, aes(x = Depth, y = ..density..)) + # plotting geom_histogram(bins = 20, colour = &quot;#80593D&quot;, fill = &quot;#9FC29F&quot;, boundary = 0) + geom_density(color = &quot;#3D6480&quot;) + facet_wrap(~Year) + # formatting ggtitle(&quot;Severe Drought Led to Finches with Bigger Chompers&quot;, subtitle = &quot;Beak Depth Density of Galapagos Finches by Year&quot;) + labs(x = &quot;Beak Depth (mm)&quot;, caption = &quot;Source: Sleuth3::case0201&quot;) + theme(plot.title = element_text(face = &quot;bold&quot;)) + theme(plot.subtitle = element_text(face = &quot;bold&quot;, color = &quot;grey35&quot;)) + theme(plot.caption = element_text(color = &quot;grey68&quot;)) Pour plus d’information sur le jeu de donnée, tapez ?Sleuth3::case0201 dans la console. 5.3 Simple examples Whoa whoa whoa! Plus simple s’il vous plait! Utilisons un jeu de données très simple : # store data x &lt;- c(50, 51, 53, 55, 56, 60, 65, 65, 68) 5.3.1 Histogramme de base en R # plot data hist(x, col = &quot;lightblue&quot;, main = &quot;Base R Histogram of x&quot;) L’avantage des histogrammes de base en R est qu’ils sont faciles à réaliser. En vérité, tout ce dont vous avez besoin pour afficher la donnée x est d’utiliser hist(x). Mais nous y ajoutons un petit peu de couleur pour le rendre plus présentable.. La documentation complete de hist() peut être trouver ici 5.3.2 Histogramme avec ggplot2 # import ggplot library(ggplot2) # must store data as dataframe df &lt;- data.frame(x) # plot data ggplot(df, aes(x)) + geom_histogram(color = &quot;grey&quot;, fill = &quot;lightBlue&quot;, binwidth = 5, center = 52.5) + ggtitle(&quot;ggplot2 histogram of x&quot;) La version ggplot des histogramme est un peu plus compliquée en apparence, mais elle vous donnera plus de contrôle sur le résultat. Note : Comme montré ci-dessus, ggplot requière un dataframe en entrée. Donc si vous rencontrez une erreur du type “R doesn’t know what to do” comme ça : ggplot dataframe error vérifiez que vous utilisez des dataframes. 5.4 Théorie De façon générale, un histogramme est une des nombreuses façon de représenter des données continues. Un histogramme est claire et facile à faire. Les histogrammes sont relativement manifestes : ils présentent la distribution empirique de vos données dans un jeu d’intervalles donné. Les histogrammes peuvent être employés sur des données brutes pour avoir une idée de leur distribution sans réaliser de manipulations compliquées. Nous recommendons les histogrammes pour avoir un sens basique et pratique de la distribution de vos données avec le minimum de traitement. Pour plus d’info sur les histogrammes et les variables continues, regardez Chapter 3 du livre. 5.5 Types d’histogrammes Utilisez un histogramme pour représenter la distribution d’une variable continue. L’axe des y peut représenter une grande variété de résultats : 5.5.1 Frequence ou compte y = nombre de valeur dans chaque bâton. 5.5.2 Frequence relative y = nombre de valeur dans chaque bâton / nombre total de valeur 5.5.3 Frequence cumulée y = nombre total de valeur plus petite que la bordure droite du bâton. 5.5.4 Densité y = frequence relative / largeur des bâtons 5.6 Paramètres 5.6.1 Limite droite et gauches des bâtons Soyez vigilent avec les limites car un point peut tomber dans le bâton de droite ou de gauche en fonction de la configuration des limites que vous avez choisis. # format layout op &lt;- par(mfrow = c(1, 2), las = 1) # right closed hist(x, col = &quot;lightblue&quot;, ylim = c(0, 4), xlab = &quot;right closed ex. (55, 60]&quot;, font.lab = 2) # right open hist(x, col = &quot;lightblue&quot;, right = FALSE, ylim = c(0, 4), xlab = &quot;right open ex. [55, 60)&quot;, font.lab = 2) 5.6.2 Nombre de bâtons Le nombre de bâtons par défaut dans ggplot2 est 30 mais ce n’est pas toujours le choix idéal. Par conséquent pensez à le modifier si le résultat vous parait étrange. Vous pouvez le faire en utilisant binwidth et préciser la largeur de bande que vous souhaitez, ou bien vous pouvez donner directement le nombre de bâton souhaiter en utilisant bins. # default...note the pop-up about default bin number ggplot(finches, aes(x = Depth)) + geom_histogram() + ggtitle(&quot;Default with pop-up about bin number&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Voici quelques exemples en utilisant les deux méthodes décrites plus haut : # using binwidth p1 &lt;- ggplot(finches, aes(x = Depth)) + geom_histogram(binwidth = 0.5, boundary = 6) + ggtitle(&quot;Changed binwidth value&quot;) # using bins p2 &lt;- ggplot(finches, aes(x = Depth)) + geom_histogram(bins = 48, boundary = 6) + ggtitle(&quot;Changed bins value&quot;) # format plot layout library(gridExtra) grid.arrange(p1, p2, ncol = 2) 5.6.3 Alignement des bâtones Vérifiez que vos axes reflètent les vraies limites de votre histogramme. Vous pouvez utiliser boundary pour préciser le point final de n’importe quel bâton. Vous pouvez également utiliser center pour préciser le centre d’un bâton. ggplot2 est en mesure de calculer où placer tous les autres bâtons (aussi, remarquez que lorsque la limite a été changée, le nombre de bâton a diminué de 1. Cela est dû au fait que par défaut les bâtons sont centrés vont au-dessus/dessous de l’intervalle des données.) df &lt;- data.frame(x) # default alignment ggplot(df, aes(x)) + geom_histogram(binwidth = 5, fill = &quot;lightBlue&quot;, col = &quot;black&quot;) + ggtitle(&quot;Default Bin Alignment&quot;) # specify alignment with boundary p3 &lt;- ggplot(df, aes(x)) + geom_histogram(binwidth = 5, boundary = 60, fill = &quot;lightBlue&quot;, col = &quot;black&quot;) + ggtitle(&quot;Bin Alignment Using boundary&quot;) # specify alignment with center p4 &lt;- ggplot(df, aes(x)) + geom_histogram(binwidth = 5, center = 67.5, fill = &quot;lightBlue&quot;, col = &quot;black&quot;) + ggtitle(&quot;Bin Alignment Using center&quot;) # format layout library(gridExtra) grid.arrange(p3, p4, ncol = 2) Note : Ne pas utiliser à la fois boundary et center pour l’alignement. Choisissez-en un seul. 5.7 Histogramme interactif avec ggvis Le package ggvis est toujours en cours de développement, mais certaines choises marchent déjà très bien tels que l’ajustement interactive de certains paramètre en codant. Comme les images ne peuvent pas être partager en utilisant knit (comme pour les autres package comme plotly), nous présentons ici que le code et pas le résultat. Pour essayer copier-collez le code suivant dans une session R.. 5.7.1 Changer la largeur de bande de façon interactive library(tidyverse) library(ggvis) faithful %&gt;% ggvis(~eruptions) %&gt;% layer_histograms(fill := &quot;lightblue&quot;, width = input_slider(0.1, 2, value = .1, step = .1, label = &quot;width&quot;)) 5.7.2 GDP df &lt;-read.csv(&quot;countries2012.csv&quot;) df %&gt;% ggvis(~GDP) %&gt;% layer_histograms(fill := &quot;green&quot;, width = input_slider(500, 10000, value = 5000, step = 500, label = &quot;width&quot;)) 5.7.3 Changer le centre de façon interactive df &lt;- data.frame(x = c(50, 51, 53, 55, 56, 60, 65, 65, 68)) df %&gt;% ggvis(~x) %&gt;% layer_histograms(fill := &quot;red&quot;, width = input_slider(1, 10, value = 5, step = 1, label = &quot;width&quot;), center = input_slider(50, 55, value = 52.5, step = .5, label = &quot;center&quot;)) 5.7.4 Changer le centre (avec affichage des valeurs) df &lt;- data.frame(x = c(50, 51, 53, 55, 56, 60, 65, 65, 68), y = c(.5, .5, .5, .5, .5, .5, .5, 1.5, .5)) df %&gt;% ggvis(~x, ~y) %&gt;% layer_histograms(fill := &quot;lightcyan&quot;, width = 5, center = input_slider(45, 55, value = 45, step = 1, label = &quot;center&quot;)) %&gt;% layer_points(fill := &quot;blue&quot;, size := 200) %&gt;% add_axis(&quot;x&quot;, properties = axis_props(labels = list(fontSize = 20))) %&gt;% scale_numeric(&quot;x&quot;, domain = c(46, 72)) %&gt;% add_axis(&quot;y&quot;, values = 0:3, properties = axis_props(labels = list(fontSize = 20))) 5.7.5 Changer les limites droites et gauches de façon interactive df %&gt;% ggvis(~x) %&gt;% layer_histograms(fill := &quot;red&quot;, width = input_slider(1, 10, value = 5, step = 1, label = &quot;width&quot;), boundary = input_slider(47.5, 50, value = 50, step = .5, label = &quot;boundary&quot;)) 5.8 Ressources externes hist documentation: Documentation sur les histogramme en base R. ggplot2 cheatsheet: Toujours bon d’y jeter un oeil. "],
["box.html", "6 Chart: Boxplot 6.1 tl;dr 6.2 Exemples simples 6.3 Théorie 6.4 Quand l’utiliser 6.5 Considérations 6.6 Ressources externes", " 6 Chart: Boxplot 6.1 tl;dr Je veux un exemple sympa et je le veux MAINTENANT ! Voici un aperçu d’une répartition des poids des poussins selon le supplément de nourriture qu’ils ont reçus : Et en voici le code : library(ggplot2) # boxplot by feed supplement ggplot(chickwts, aes(x = reorder(feed, -weight, median), y = weight)) + # plotting geom_boxplot(fill = &quot;#cc9a38&quot;, color = &quot;#473e2c&quot;) + # formatting ggtitle(&quot;Casein Makes You Fat?!&quot;, subtitle = &quot;Boxplots of Chick Weights by Feed Supplement&quot;) + labs(x = &quot;Feed Supplement&quot;, y = &quot;Chick Weight (g)&quot;, caption = &quot;Source: datasets::chickwts&quot;) + theme_grey(16) + theme(plot.title = element_text(face = &quot;bold&quot;)) + theme(plot.subtitle = element_text(face = &quot;bold&quot;, color = &quot;grey35&quot;)) + theme(plot.caption = element_text(color = &quot;grey68&quot;)) Pour plus d’informations sur le jeu de données, tapez ?datasets::chickwts au sein du terminal. 6.2 Exemples simples D’accord… Réellement plus simple s’il-vous-plaît. 6.2.1 Boxplots unique R vous donne de base un rapide “boxplot” (littéralement boite à moustache en français) d’un vecteur ou d’une colonne unique basée sur une trame de données, et cela avec très peu de code : # vector boxplot(rivers) Ou bien sa version horizontale : # single column of a data frame boxplot(chickwts$weight, horizontal = TRUE) Créer un boxplot unique avec ggplot2 est quelque peu problématique. (La blague est que c’est la manière de l’auteur du package de vous dire que si vous avez un groupe, faites plutôt un histogramme !) Si vous n’incluez qu’une correspondance esthétique, la variable x (en tant que groupe) sera supposée et vous aurez une erreur : ggplot(chickwts, aes(weight)) + geom_boxplot() Error: stat_boxplot requires the following missing aesthetics: y Cela peut être corrigé par y = pour indiquer que weight est la variable numérique, mais vous aurez malgré tout un axe x dénué de sens : ggplot(chickwts, aes(y = weight)) + geom_boxplot() + theme_grey(16) # make all font sizes larger (default is 11) Une approche plus propre consiste à créer un nom pour le groupe unique, l’esthétique x et à supprimer le libellé de l’axe x : ggplot(chickwts, aes(x = &quot;all 71 chickens&quot;, y = weight)) + geom_boxplot() + xlab(&quot;&quot;) + theme_grey(16) 6.2.2 Boxplots multiples utilisant ggplot2 Pour créer des boxplots multiples avec ggplot2, votre trame de données nécessite d’être ordonnée ; formulé autrement, vous avez besoin d’une colonne avec des niveaux de la variable de groupement. Cela peut être une classe de facteurs, de caractères ou de chiffres. str(chickwts) ## &#39;data.frame&#39;: 71 obs. of 2 variables: ## $ weight: num 179 160 136 227 217 168 108 124 143 140 ... ## $ feed : Factor w/ 6 levels &quot;casein&quot;,&quot;horsebean&quot;,..: 2 2 2 2 2 2 2 2 2 2 ... Nous voyons que chickwts a la bonne apparence: Nous avons une colonne feed avec 6 niveaux de facteurs, de sorte que nous pouvons définir l’esthétique x à feed. Nous ordonnons également les boxplots en diminuant le poids médian : ggplot(chickwts, aes(x = reorder(feed, -weight, median), y = weight)) + geom_boxplot() + xlab(&quot;feed type&quot;) + theme_grey(16) Les trames de données qui contiennent une colonne séparée de valeurs pour chaque boxplot désiré doivent être ordonnées d’abord. (Pour plus de détails sur l’utilisation de tidy::gather(), voir ce tutoriel.) library(tidyverse) head(attitude) ## rating complaints privileges learning raises critical advance ## 1 43 51 30 39 61 92 45 ## 2 63 64 51 54 63 73 47 ## 3 71 70 68 69 76 86 48 ## 4 61 63 45 47 54 84 35 ## 5 81 78 56 66 71 83 47 ## 6 43 55 49 44 54 49 34 tidyattitude &lt;- attitude %&gt;% gather(key = &quot;question&quot;, value = &quot;rating&quot;) head(tidyattitude) ## question rating ## 1 complaints 51 ## 2 complaints 64 ## 3 complaints 70 ## 4 complaints 63 ## 5 complaints 78 ## 6 complaints 55 Maintenant nous sommes prêts à tracer : ggplot(tidyattitude, aes(reorder(question, -rating, median), rating)) + geom_boxplot() + xlab(&quot;question short name&quot;) + theme_grey(16) 6.3 Théorie Voici une citation de Hadley Wickham qui résume les boxplots plutôt bien : Un boxplot est un résumé de distribution compacte, affichant moins de détails qu’un histogramme ou que la densité d’un noyau, mais qui prend également moins d’espace. Les boxplots utilisent des statistiques récapitulatives robustes qui sont constamment localisées à des points de données actuels, qui sont rapidement calculables (à l’origine, à la main), et qui n’ont aucun paramètre d’optimisation. Ils sont particulièrement utiles pour comparer les distributions au travers de groupes. - Hadley Wickham Un autre usage important du boxplot est l’affichage de valeurs abérrantes. Un boxplot révèle combien abérrante un point de données peut être avec des quartiles et des clôtures. Utilisez le boxplot lorsque vous avez des données avec des valeurs abérrantes de sorte qu’elles soient exposées. Ce qui lui manque en spécificité, il le contre-balance avec sa capacité à résumer clairement de larges jeux de données. Pour plus d’informations sur les boxplots et les variables continues, jetez un coup d’oeil au Chapitre 3 du livre. 6.4 Quand l’utiliser Les boxplots devraient être utilisés pour afficher des variables continues. Ils sont particulièrement utiles pour identifier les valeurs abérrantes et comparer différents groupes. Note : Les boxplots peuvent même parfois vous aider à convaincre quelqu’un que vous êtes leur valeur abérrante (Si vous aimez quand les gens détaillent leurs blagues, voici pourquoi cette BD est drôle.). 6.5 Considérations 6.5.1 Orientation retournée La plupart du temps, vous souhaiterez des boxplots horizontaux. C’est super facile avec ggplot2 : faites juste un + coord_flip() et supprimez le - du réordonnement de sorte que le niveau de facteur avec la plus haute médiane soit au-dessus : ggplot(tidyattitude, aes(reorder(question, rating, median), rating)) + geom_boxplot() + coord_flip() + xlab(&quot;question short name&quot;) + theme_grey(16) Notez que permuter x et y plutôt que d’utiliser coord_flip() ne marche pas ! ggplot(tidyattitude, aes(rating, reorder(question, rating, median))) + geom_boxplot() + ggtitle(&quot;This is not what we wanted!&quot;) + ylab(&quot;question short name&quot;) + theme_grey(16) 6.5.2 PAS pour des données catégorielles Les boxplots sont super, mais ils ne marchent pas avec les données catégorielles. Vérifiez que votre variable est continue avant d’utiliser les boxplots. Les données dans l’exemple suivant sont des variables du jeu de données pisaitems au sein du package likert avec des taux de 1, 2, 3 ou 4: head(pisa, 4) ## ST24Q01 ST24Q02 ST24Q03 ST24Q04 ST24Q05 ST24Q06 ## 1 2 4 4 1 4 1 ## 2 3 1 1 4 1 3 ## 3 4 1 1 3 1 4 ## 4 2 2 3 1 2 2 Créer un boxplot à partir de ces données est un bon exemple de ce qu’il ne faut pas faire : 6.6 Ressources externes Tukey, John W. 1977. Exploratory Data Analysis. Addison-Wesley. (Chapter 2): the primary source in which boxplots are first presented. Article on boxplots with ggplot2: Une excellente collection d’exemples de code sur comment réaliser des boxplots avec ggplot2. Cela couvre notamment le layering, les legendes, le faceting, le formatage , et plus encore. Si vous voulez votre boxplot d’une certaine manière cette page vous aidera certainement. Boxplots with plotly package: Un exemple de boxplot en utilisant le package plotly. En passant cela apporte par son interactivité un meilleur moyen de mettre en evidence les propriétés statistiques de votre graphique. ggplot2 Boxplot: Quick Start Guide: Article de STHDA sur comment réaliser des boxplots avec ggplot2. Excellent point de départ avec résultat immédiat dans la personalisation et le formatage. ggplot2 cheatsheet: Toujours bon d’y jeter un oeil. Hadley Wickhan and Lisa Stryjewski on boxplots: Bon pour comprendre les boxplots basiques comme plsu complexes ainsi que leur histoire. "],
["violin.html", "7 Diagramme : Violin Plot 7.1 Avant-propos 7.2 Quelques exemples en R 7.3 Ajout de quelques statistiques au violin plot 7.4 Description 7.5 Quand l’utiliser ? 7.6 Ressources externes", " 7 Diagramme : Violin Plot Ce chapitre est à l’origine une contribution de AshwinJay101 En cours de progression. Toute amélioration est la bienvenue. Si vous souhaitez participer rendez vous sur contribuer au repo. 7.1 Avant-propos Cette section couvre les violins plots. 7.2 Quelques exemples en R Utilisons le jeu de données chickwts issu du package datasets pour réaliser un violin plot avec ggplot2. Voilà le code pour le faire : # import ggplot and the Datasets Package library(datasets) library(ggplot2) supps &lt;- c(&quot;horsebean&quot;, &quot;linseed&quot;, &quot;soybean&quot;, &quot;meatmeal&quot;, &quot;sunflower&quot;, &quot;casein&quot;) # plot data ggplot(chickwts, aes(x = factor(feed, levels = supps), y = weight)) + # plotting geom_violin(fill = &quot;lightBlue&quot;, color = &quot;#473e2c&quot;) + labs(x = &quot;Feed Supplement&quot;, y = &quot;Chick Weight (g)&quot;) 7.3 Ajout de quelques statistiques au violin plot 7.3.1 Ajout de la médiane et de l’intervalle inter-quartile On peut ajouter la médianne et l’intervalle interquartile sur un violin plot. ggplot(chickwts, aes(x = factor(feed, levels = supps), y = weight)) + # plotting geom_violin(fill = &quot;lightBlue&quot;, color = &quot;#473e2c&quot;) + labs(x = &quot;Feed Supplement&quot;, y = &quot;Chick Weight (g)&quot;) + geom_boxplot(width=0.1) Pour obtenir ce résultat on ajoute juste une geom boxplot. 7.3.2 Affichage des données avec des points ggplot(chickwts, aes(x = factor(feed, levels = supps), y = weight)) + # plotting geom_violin(fill = &quot;lightBlue&quot;, color = &quot;#473e2c&quot;) + labs(x = &quot;Feed Supplement&quot;, y = &quot;Chick Weight (g)&quot;) + geom_dotplot(binaxis=&#39;y&#39;, dotsize=0.5, stackdir=&#39;center&#39;) 7.4 Description Les violin plots sont similaires au boxplots. L’avantage de ces derniers par rapport aux boxplots est qu’ils nous permette de visualiser la distribution des données et et leur densité de probabilité. On peut interpreter le violin plot comme la combinaison parfaite des boxplots et des density plots. Ce type de graphique nous permet de savoir si les données sont unimodale, bimodale ou même multi-modale. Ces détails pourtant simples sont invisible dans un boxplot. Dans un violin plot la distribution peut être vue sur la largeur. 7.5 Quand l’utiliser ? Les violin plots ne s’utilisent que sur des variables continues. 7.6 Ressources externes ggplot2 Violin Plot: Ressource excellente pour créer et personnaliser vos violin plot. "],
["ridgeline.html", "8 Diagramme : Ridgeline Plots 8.1 Avant-propos 8.2 tl;dr 8.3 Exemple simple 8.4 Ridgeline Plots avec ggridge 8.5 Quand utiliser ? 8.6 Considerations 8.7 Ressources externes", " 8 Diagramme : Ridgeline Plots Ce chapitre est à l’origine une contribution de nehasaraf1994 En cours de progression. Toute amélioration est la bienvenue. Si vous souhaitez participer rendez vous sur contribuer au repo. 8.1 Avant-propos Cette section vous apprendra comment construire un ridgeline plot. 8.2 tl;dr Je veux un exemple sympa et je le veux tout de suite, maintenant !! Ici, on observe la concentration theophylline d’un jeu de donnée portant sur les doses de theophylline administrées oralement à des sujets. Voici le code : library(&quot;ggridges&quot;) library(&quot;tidyverse&quot;) Theoph_data &lt;- Theoph ggplot(Theoph_data, aes(x=Dose,y=Subject,fill=Subject))+ geom_density_ridges_gradient(scale = 4, show.legend = FALSE) + theme_ridges() + scale_y_discrete(expand = c(0.01, 0)) + scale_x_continuous(expand = c(0.01, 0)) + labs(x = &quot;Dose of theophylline(mg/kg)&quot;,y = &quot;Subject #&quot;) + ggtitle(&quot;Density estimation of dosage given to various subjects&quot;) + theme(plot.title = element_text(hjust = 0.5)) For more info on this dataset, type ?datasets::Theoph into the console. 8.3 Exemple simple Okay…plus simple svp. Utilisons le jeu de données Orange du package datasets : library(&quot;datasets&quot;) head(Orange, n=5) ## Grouped Data: circumference ~ age | Tree ## Tree age circumference ## 1 1 118 30 ## 2 1 484 58 ## 3 1 664 87 ## 4 1 1004 115 ## 5 1 1231 120 8.4 Ridgeline Plots avec ggridge library(&quot;ggridges&quot;) library(&quot;tidyverse&quot;) ggplot(Orange, aes(x=circumference,y=Tree,fill = Tree))+ geom_density_ridges(scale = 2, alpha=0.5) + theme_ridges()+ scale_fill_brewer(palette = 4)+ scale_y_discrete(expand = c(0.8, 0)) + scale_x_continuous(expand = c(0.01, 0))+ labs(x=&quot;Circumference at Breast Height&quot;, y=&quot;Tree with ordering of max diameter&quot;)+ ggtitle(&quot;Density estimation of circumference of different types of Trees&quot;)+ theme(plot.title = element_text(hjust = 0.5)) ggridge utilise des utilises deux geoms particulières pour faire des ridgeline density plots : “geom_density_ridges” et “geom_ridgeline”. Ils sont utilisés pour afficher des densités de variables catégorielles et regarder leur distribution sur un axe lui continue. 8.5 Quand utiliser ? Les ridgeline plots peuvent être utilisés lorsque vous devez afficher différentes partie des données sur un même axe. Ce graphique présente ces différentes grandeurs avec un petit chevauchement. Les ridgeline plots sont très utiles pour visualiser la distribution d’une variable catégorielle au cours du temps ou l’espace. Un bon exemple d’utilisation des ridgeline plots est la distribution des salaires au sein de différentes entreprises. 8.6 Considerations Le niveau de chevauchement peut être contrôlé en ajustant la valeur de l’echelle (scale en anglais). L’echelle vous permet de choisir à quel point le plus haut pique de la courbe du bas peut toucher la courbe du haut. library(&quot;ggridges&quot;) library(&quot;tidyverse&quot;) OrchardSprays_data &lt;- OrchardSprays ggplot(OrchardSprays_data, aes(x=decrease,y=treatment,fill=treatment))+ geom_density_ridges_gradient(scale=3) + theme_ridges()+ scale_y_discrete(expand = c(0.3, 0)) + scale_x_continuous(expand = c(0.01, 0))+ labs(x=&quot;Response in repelling honeybees&quot;,y=&quot;Treatment&quot;)+ ggtitle(&quot;Density estimation of response by honeybees to a treatment for scale=3&quot;)+ theme(plot.title = element_text(hjust = 0.5)) ggplot(OrchardSprays_data, aes(x=decrease,y=treatment,fill=treatment))+ geom_density_ridges_gradient(scale=5) + theme_ridges()+ scale_y_discrete(expand = c(0.3, 0)) + scale_x_continuous(expand = c(0.01, 0))+ labs(x=&quot;Response in repelling honeybees&quot;,y=&quot;Treatment&quot;)+ ggtitle(&quot;Density estimation of response by honeybees to a treatment for scale=5&quot;)+ theme(plot.title = element_text(hjust = 0.5)) Les ridgeline plots peuvent être aussi utilisé pour afficher des histogrammes plutôt que des density plots. Mais cette pratique ne vous donnera très probablement pas des résultats intéressants. library(&quot;ggridges&quot;) library(&quot;tidyverse&quot;) ggplot(InsectSprays, aes(x = count, y = spray, height = ..density.., fill = spray)) + geom_density_ridges(stat = &quot;binline&quot;, bins = 20, scale = 0.7, draw_baseline = FALSE) Si on fait la même chose avec des ridgeline plots, c’est quand même mieux. library(&quot;ggridges&quot;) library(&quot;tidyverse&quot;) ggplot(InsectSprays, aes(x=count,y=spray,fill=spray))+ geom_density_ridges_gradient() + theme_ridges()+ labs(x=&quot;Count of Insects&quot;,y=&quot;Types of Spray&quot;)+ ggtitle(&quot;The counts of insects treated with different insecticides.&quot;)+ theme(plot.title = element_text(hjust = 0.5)) 8.7 Ressources externes Introduction to ggridges: Une excellente collection d’exemple de code sur comment réaliser des ridgeline plots avec ggplot2. Cela couvre tous les paramètres de ggridges et comment les modifier pour avoir une meilleure visualisation. Si vous voulez personaliser votre ridgeline plot cet article vous aidera certainement. Article on ridgeline plots with ggplot2: Quelques exemples. Un bon point de départ pour les ridgeline plots. History of Ridgeline plots: Théorie des ridgeline plots. "],
["qqplot.html", "9 Diagramme : QQ-Plot 9.1 Introduction 9.2 Interpretation des qqplots 9.3 Normal ou pas (example avec qqnorm) 9.4 Différents genre de qqplots 9.5 qqplot avec ggplot 9.6 References", " 9 Diagramme : QQ-Plot Ce chapitre est à l’origine une contribution de hao871563506 En cours de progression. Toute amélioration est la bienvenue. Si vous souhaitez participer rendez vous sur contribuer au repo. 9.1 Introduction En statistiques, un Q-Q (quantile-quantile) plot est une méthode graphique pour comparer deux distributions de probabilité en affachant leur quantiles contre quantiles. Un point (x,y) du graphique représente un quantile de la seconde distribution (axe y) contre le même quantile de la première distribution (axe x). Ainsi la droite est une courbe paramétrique dont le paramètre est le nombre d’intervalle des quantiles. 9.2 Interpretation des qqplots 9.3 Normal ou pas (example avec qqnorm) 9.3.1 qqplot normal x &lt;- rnorm(1000, 50, 10) qqnorm(x) qqline(x, col = &quot;red&quot;) Les points semblent s’aligner le long de la droite. Remarquez que sur l’axe des x il s’agit des quantiles théoriques. Ces quantiles sont ceux de la distribution normale centrée réduite. 9.3.2 qqplot non-normal x &lt;- rexp(1000, 5) qqnorm(x) qqline(x, col = &quot;red&quot;) Remarquez que les forment une courbe et non pas une droite. Un Q-Q plot normal qui ressemble à ça indique que votre échantillon est biaisé (skewed en anglais) 9.4 Différents genre de qqplots Le graphique suivant est une compilation des différents types de qqplots. via Stack Exchange Normal qqplot: La distribution normale est symétrique, donc aucun biais (skew) (la moyenne est égale à la médiane). Right skewed qqplot: Right-skew aussi appelé positive skew. Left skewed qqplot: Left-skew aussi appelé negative skew. Light tailed qqplot: Cela veut dire que comparé à la distribution normale il y a un peu plus de données dans les extrémités que dans le centre de la distribution. Heavy tailed qqplot: Cela veut dire que comparé à la distribution normale il y a un beaucoup plus de données dans les extrémités que dans le centre de la distribution. Biomodel qqplot: illustre une distribution bimodale. 9.5 qqplot avec ggplot Pour faire un qqplot avec ggplot2 on doit utiliser un dataframe, ainsi nous commençons par convertir notre structure de données. On peut voir qu’avec ggplot le qqplot donne un résultat similaire à celui obtenu en utilisant qqnorm. library(ggplot2) x &lt;- rnorm(1000, 50, 10) x &lt;- data.frame(x) ggplot(x, aes(sample = x)) + stat_qq() + stat_qq_line() Néanmoins, si on a besoin d’afficher différents groupes, ggplot est très utile et permet une coloration par facteurs. library(ggplot2) ggplot(mtcars, aes(sample = mpg, colour = factor(cyl))) + stat_qq() + stat_qq_line() 9.6 References Understanding Q-Q Plots: Une discussion de University of Virginia Library sur les qqplots. How to interpret a QQ plot: Une autre ressource sur l’interprétation des qqplots. A QQ Plot Dissection Kit: Une excellente revue exhaustive des qqplots par Sean Kross. Probability plotting methods for the analysis of data: Article sur les techniques d’affichage notamment pour les qqplots. (Wilk, M.B.; Gnanadesikan, R. (1968)) QQ-Plot Wiki: Wikipedia sur les qqplots "],
["bar.html", "10 Diagramme : Bar Chart 10.1 Avant-propos 10.2 tl;dr 10.3 Exemples simples 10.4 Théorie 10.5 Quand utiliser ? 10.6 Considérations 10.7 Modifications 10.8 Ressources externes", " 10 Diagramme : Bar Chart 10.1 Avant-propos Cette section est dédiée à comment faire des bar charts. 10.2 tl;dr Je veux un exemple sympa. Pas demain, pas après le p’tit dej. Tout de suite !! Voici un bar chart qui montre le taux de survie des passagers à bord du RMS Titanic : Et voilà le code : library(datasets) # data library(ggplot2) # plotting library(dplyr) # manipulation # Combine Children and Adult stats together ship_grouped &lt;- as.data.frame(Titanic) %&gt;% group_by(Class, Sex, Survived) %&gt;% summarise(Total = sum(Freq)) ggplot(ship_grouped, aes(x = Survived, y = Total, fill = Sex)) + geom_bar(position = &quot;dodge&quot;, stat = &quot;identity&quot;) + geom_text(aes(label = Total), position = position_dodge(width = 0.9), vjust = -0.4, color = &quot;grey68&quot;) + facet_wrap(~Class) + # formatting ylim(0, 750) + ggtitle(&quot;Don&#39;t Be A Crew Member On The Titanic&quot;, subtitle = &quot;Survival Rates of Titanic Passengers by Class and Gender&quot;) + scale_fill_manual(values = c(&quot;#b2df8a&quot;, &quot;#a6cee3&quot;)) + labs(y = &quot;Passenger Count&quot;, caption = &quot;Source: titanic::titanic_train&quot;) + theme(plot.title = element_text(face = &quot;bold&quot;)) + theme(plot.subtitle = element_text(face = &quot;bold&quot;, color = &quot;grey35&quot;)) + theme(plot.caption = element_text(color = &quot;grey68&quot;)) Pour plus d’inforamtion sur le jeu de données, tapez ?datasets::Titanic dans le terminal. 10.3 Exemples simples J’ai eu les yeux plus gros que le ventres. Plus simple svp ! Utilisons plutôt le jeu de données HairEyeColor. Pour commencer, nous allons juste regarder les différents catégories de couleurs de cheveux au sein de la population féminine : colors &lt;- as.data.frame(HairEyeColor) # just female hair color, using dplyr colors_female_hair &lt;- colors %&gt;% filter(Sex == &quot;Female&quot;) %&gt;% group_by(Hair) %&gt;% summarise(Total = sum(Freq)) # take a look at data head(colors_female_hair) ## # A tibble: 4 x 2 ## Hair Total ## &lt;fct&gt; &lt;dbl&gt; ## 1 Black 52 ## 2 Brown 143 ## 3 Red 37 ## 4 Blond 81 Maintenant faisons quelques graphiques avec ces données. 10.3.1 Bar chart avec la base R barplot(colors_female_hair[[&quot;Total&quot;]], names.arg = colors_female_hair[[&quot;Hair&quot;]], main = &quot;Bar Graph Using Base R&quot;) Nous recommendons la base R uniquement pour les bar chart simples ou pour votre usage personnel. Comme tous les autres graphiques la base R est simple à mettre en oeuvre. Note : La base R requière un vecteur ou une matrice, en d’autres termes l’objet avec doubles crochets dans l’appel à barplot (qui permet de récupérer les colones comme des listes). 10.3.2 Bar chart avec ggplot2 library(ggplot2) # plotting ggplot(colors_female_hair, aes(x = Hair, y = Total)) + geom_bar(stat = &quot;identity&quot;) + ggtitle(&quot;Bar Graph Using ggplot2&quot;) Les bar chart sont très simple avec ggplot2. Il suffit de lui passer en argument un dataframe et les différentes aesthetics qui vous intéresse. Note : Dans ce cas, on a une table de valeurs et on veut explicitement représenter des barres par en hauteur. A cause de ça, on précise l’aesthetic y comme colonne Total, mais on doit également spécifier stat = &quot;identity&quot; dans geom_bar() pour que le module sache ce qu’il faut afficher et le faire correctement. Souvent vous aurez des jeux de données où chaque ligne est une observation et vous voudrez les grouper dans les barres. Dans ce cas là l’aesthetic y et stat = &quot;identity&quot; n’auront pas besoin d’être précisé. 10.4 Théorie Pour plus d’info sur l’affichage des données de type catégorielle, regardez Chapter 4 dans le livre. 10.5 Quand utiliser ? Les bar charts s’utilisent essentiellement pour les données catégorielles. Souvent vous aurez une collection de facteurs que vous voudrez diviser en différents groupes. 10.6 Considérations 10.6.1 Pas pour les données continues.. Si vous trouvez que votre bar chart n’a pas un aspect agréable, vérifiez que vous données sont bien catégorielles et pas continues. Si vous voulez afficher des données continues avec des barres, c’est le job des histogrammes 10.7 Modifications ces modifications suppose l’utilisation de ggplot2. 10.7.1 Inversion des barres Pour inverser l’orientation des barres, ajouter un coord_flip() : ggplot(colors_female_hair, aes(x = Hair, y = Total)) + geom_bar(stat = &quot;identity&quot;) + ggtitle(&quot;Bar Graph Using ggplot2&quot;) + coord_flip() 10.7.2 Reordonner les barres En base R comme avec ggplot2 les barres apparaissent par ordre alphabétique. Regardez ce tutoriel pour une explication détaillée sur comment les barres doivent être ordonnées dans un bar chart, et comment le package forecats peut vous y aider. 10.7.3 Facet Wrap Vous pouvez séparer un graphique en plusieurs petit sous-graphique en utilisant facet_wrap() (n’oubliez pas le tilde, ~): ggplot(colors, aes(x = Sex, y = Freq)) + geom_bar(stat = &quot;identity&quot;) + facet_wrap(~Hair) 10.8 Ressources externes Cookbook for R: Discussion sur comment réordonner les niveau d’un facteur. DataCamp Exercise: Exercice simple sur comment faire des bar chart avec ggplot2. ggplot2 cheatsheet: Toujours bon d’y jeter un oeil. "],
["cleveland.html", "11 Diagramme : Cleveland Dot Plot 11.1 Avant-propos 11.2 Multiple dot plots", " 11 Diagramme : Cleveland Dot Plot En cours de progression. Toute amélioration est la bienvenue. Si vous souhaitez participer rendez vous sur contribuer au repo. 11.1 Avant-propos Cette section explique comment réaliser des Cleveland dot plots. Ces graphiques sont une bonne alternative à de simple bar chart, particulièrement si vous avez beaucoup d’éléments différents dans votre jeu de données. Pour que les légendes d’un bar chart se superposent c’est très rapide. Avec le même espace, beaucoup plus de valeurs peuvent être incluses dans un dot plot, et cela est de fait plus facile à lire. R possède une fonction de base dotchart(), mais comme il s’agit d’un graphe très simple le faire “from scratch” en base R ou en ggplot2 vous permet une plus grand personnalisation. Le code : library(tidyverse) # create a theme for dot plots, which can be reused theme_dotplot &lt;- theme_bw(14) + theme(axis.text.y = element_text(size = rel(.75)), axis.ticks.y = element_blank(), axis.title.x = element_text(size = rel(.75)), panel.grid.major.x = element_blank(), panel.grid.major.y = element_line(size = 0.5), panel.grid.minor.x = element_blank()) # move row names to a dataframe column df &lt;- swiss %&gt;% tibble::rownames_to_column(&quot;Province&quot;) # create the plot ggplot(df, aes(x = Fertility, y = reorder(Province, Fertility))) + geom_point(color = &quot;blue&quot;) + scale_x_continuous(limits = c(35, 95), breaks = seq(40, 90, 10)) + theme_dotplot + xlab(&quot;\\nannual live births per 1,000 women aged 15-44&quot;) + ylab(&quot;French-speaking provinces\\n&quot;) + ggtitle(&quot;Standardized Fertility Measure\\nSwitzerland, 1888&quot;) 11.2 Multiple dot plots Pour cet exemple nous utiliseront les données de 2010 sur les scores moyens de staisfaction d’un échantillon des écoles publiques de NYC. df &lt;- read_csv(&quot;data/SAT2010.csv&quot;, na = &quot;s&quot;) ## Parsed with column specification: ## cols( ## DBN = col_character(), ## `School Name` = col_character(), ## `Number of Test Takers` = col_double(), ## `Critical Reading Mean` = col_double(), ## `Mathematics Mean` = col_double(), ## `Writing Mean` = col_double() ## ) set.seed(5293) tidydf &lt;- df %&gt;% filter(!is.na(`Critical Reading Mean`)) %&gt;% sample_n(20) %&gt;% rename(Reading = &quot;Critical Reading Mean&quot;, Math = &quot;Mathematics Mean&quot;, Writing = &quot;Writing Mean&quot;) %&gt;% gather(key = &quot;Test&quot;, value = &quot;Mean&quot;, &quot;Reading&quot;, &quot;Math&quot;, &quot;Writing&quot;) ggplot(tidydf, aes(Mean, `School Name`, color = Test)) + geom_point() + ggtitle(&quot;Schools are sorted alphabetically&quot;, sub = &quot;not the best option&quot;) + ylab(&quot;&quot;) + theme_dotplot Notez que School Name est trié par niveau de facteur, qui par défaut est en ordre alphabétique. Un meilleur choix est de trier par un des niveau de Test. C’est généralement la meilleur façon pour trier des facteurs et mettre en évidence des motifs. Pour réaliser un double tri de School Name par Test et ensuite Mean, on utilise forcats::fct_reorder2(). Cette fonction trie .f (un facteur ou un vecteur de caractères) en triant deux vecteurs .x et .y. Pour ce type de graphique, .x est la variable représentée par les points de couleurs et .y est la variable continues tracée sur l’axe des y. Supposons que nous voulons trier les écoles par score de lecture moyen. On peut le faire en limitant la variable Test à “Reading” lorsque l’on trie sur Mean : ggplot(tidydf, aes(Mean, fct_reorder2(`School Name`, Test==&quot;Reading&quot;, Mean, .desc = FALSE), color = Test)) + geom_point() + ggtitle(&quot;Schools sorted by Reading mean&quot;) + ylab(&quot;&quot;) + theme_dotplot (Un grand merci à Zeyu Qiu pour le conseil sir comment régler .x directement en niveau de facteur, une meilleure approche que le réordonnement de facteurs pour s’adapter à fct_reorder2(), comme mentionné plus haut). Bien qu’il s’agisse d’une méthode directe, il y aura peut-être des cas où il sera plus facile de préciser que vous voulez trier par rapport au premier ou au dernier facteur de la variable Test sans l’expliciter. Si un niveau de facteur n’est pas spécifier, par défaut fct_reorder2() triera par rapport au dernier facteur de .x. Dans notre cas, “Writing” est le dernier facteur de Test : ggplot(tidydf, aes(Mean, fct_reorder2(`School Name`, Test, Mean, .desc = FALSE), color = Test)) + geom_point() + ggtitle(&quot;Schools sorted by Writing mean&quot;) + ylab(&quot;&quot;) + theme_dotplot Si vous voulez trier par rapport au premier facteur de .x, “Math” dans notre cas, vous aurez besoin de la version dev de forcats que vous pouvez installer via : devtools::install_github(&quot;tidyverse/forcats&quot;) Changer la fonction de trie par défaut last2()par first2() : ggplot(tidydf, aes(Mean, fct_reorder2(`School Name`, Test, Mean, .fun = first2, .desc = FALSE), color = Test)) + geom_point() + ggtitle(&quot;Schools sorted by Math mean&quot;) + ylab(&quot;&quot;) + theme_dotplot "],
["scatter.html", "12 Diagramme : Scatterplot 12.1 Avant-propos 12.2 tl;dr 12.3 Exemples simples 12.4 Théorie 12.5 Quand utiliser ? 12.6 Considérations 12.7 Modifications 12.8 Ressources externes", " 12 Diagramme : Scatterplot 12.1 Avant-propos Cette section présente comment construire un scatterplot (nuage de points en français). 12.2 tl;dr Un exemple cool MAINTENANT! Je veux, je veux, JE VEUX ! On s’interesse ici à la relation entre le poids du cerveau et le poids du corps de 62 espèces de mamifères terrestres : Voici le code : library(MASS) # data library(ggplot2) # plotting # ratio for color choices ratio &lt;- mammals$brain / (mammals$body*1000) ggplot(mammals, aes(x = body, y = brain)) + # plot points, group by color geom_point(aes(fill = ifelse(ratio &gt;= 0.02, &quot;#0000ff&quot;, ifelse(ratio &gt;= 0.01 &amp; ratio &lt; 0.02, &quot;#00ff00&quot;, ifelse(ratio &gt;= 0.005 &amp; ratio &lt; 0.01, &quot;#00ffff&quot;, ifelse(ratio &gt;= 0.001 &amp; ratio &lt; 0.005, &quot;#ffff00&quot;, &quot;#ffffff&quot;))))), col = &quot;#656565&quot;, alpha = 0.5, size = 4, shape = 21) + # add chosen text annotations geom_text(aes(label = ifelse(row.names(mammals) %in% c(&quot;Mouse&quot;, &quot;Human&quot;, &quot;Asian elephant&quot;, &quot;Chimpanzee&quot;, &quot;Owl monkey&quot;, &quot;Ground squirrel&quot;), paste(as.character(row.names(mammals)), &quot;→&quot;, sep = &quot; &quot;),&#39;&#39;)), hjust = 1.12, vjust = 0.3, col = &quot;grey35&quot;) + geom_text(aes(label = ifelse(row.names(mammals) %in% c(&quot;Golden hamster&quot;, &quot;Kangaroo&quot;, &quot;Water opossum&quot;, &quot;Cow&quot;), paste(&quot;←&quot;, as.character(row.names(mammals)), sep = &quot; &quot;),&#39;&#39;)), hjust = -0.12, vjust = 0.35, col = &quot;grey35&quot;) + # customize legend/color palette scale_fill_manual(name = &quot;Brain Weight, as the\\n% of Body Weight&quot;, values = c(&#39;#d7191c&#39;,&#39;#fdae61&#39;,&#39;#ffffbf&#39;,&#39;#abd9e9&#39;,&#39;#2c7bb6&#39;), breaks = c(&quot;#0000ff&quot;, &quot;#00ff00&quot;, &quot;#00ffff&quot;, &quot;#ffff00&quot;, &quot;#ffffff&quot;), labels = c(&quot;Greater than 2%&quot;, &quot;Between 1%-2%&quot;, &quot;Between 0.5%-1%&quot;, &quot;Between 0.1%-0.5%&quot;, &quot;Less than 0.1%&quot;)) + # formatting scale_x_log10(name = &quot;Body Weight&quot;, breaks = c(0.01, 1, 100, 10000), labels = c(&quot;10 g&quot;, &quot;1 kg&quot;, &quot;100 kg&quot;, &quot;10K kg&quot;)) + scale_y_log10(name = &quot;Brain Weight&quot;, breaks = c(1, 10, 100, 1000), labels = c(&quot;1 g&quot;, &quot;10 g&quot;, &quot;100 g&quot;, &quot;1 kg&quot;)) + ggtitle(&quot;An Elephant Never Forgets...How Big A Brain It Has&quot;, subtitle = &quot;Brain and Body Weights of Sixty-Two Species of Land Mammals&quot;) + labs(caption = &quot;Source: MASS::mammals&quot;) + theme(plot.title = element_text(face = &quot;bold&quot;)) + theme(plot.subtitle = element_text(face = &quot;bold&quot;, color = &quot;grey35&quot;)) + theme(plot.caption = element_text(color = &quot;grey68&quot;)) + theme(legend.position = c(0.832, 0.21)) Pour plus d’info sur le jeu de données, tapez ?MASS::mammals dans le terminal. Et si ça vous rend fou de ne pas savoir quelle espèce est dans le coin en haut à droite, c’est une autre éléphant. Plus précisement c’est un éléphant africain. Il n’oublie jamais à quel point son cerveau est grand. 12.3 Exemples simples C’était trop sophistiqué ! Plus simple svp ! Utilisons le jeu de données SpeedSki du package GDAdata pour regarder comment la vitesse atteinte par les participants est reliée à leur année de naissance : library(GDAdata) head(SpeedSki, n = 7) ## Rank Bib FIS.Code Name Year Nation Speed Sex Event ## 1 1 61 7039 ORIGONE Simone 1979 ITA 211.67 Male Speed One ## 2 2 59 7078 ORIGONE Ivan 1987 ITA 209.70 Male Speed One ## 3 3 66 190130 MONTES Bastien 1985 FRA 209.69 Male Speed One ## 4 4 57 7178 SCHROTTSHAMMER Klaus 1979 AUT 209.67 Male Speed One ## 5 5 69 510089 MAY Philippe 1970 SUI 209.19 Male Speed One ## 6 6 75 7204 BILLY Louis 1993 FRA 208.33 Male Speed One ## 7 7 67 7053 PERSSON Daniel 1975 SWE 208.03 Male Speed One ## no.of.runs ## 1 4 ## 2 4 ## 3 4 ## 4 4 ## 5 4 ## 6 4 ## 7 4 12.3.1 Scatterplot de base en R x &lt;- SpeedSki$Year y &lt;- SpeedSki$Speed # plot data plot(x, y, main = &quot;Scatterplot of Speed vs. Birth Year&quot;) Les scatterpolts de base en R sont faciles à faire. Tout ce dont vous avez besoin c’est deux variables que vous vouler représenter. Bien que les scatterplots sont faisables avec des données catégorielles, les variables avec lesquelles vous travaillerez dans ce cadre seront générallement continues. 12.3.2 Scatterplot avec ggplot2 library(GDAdata) # data library(ggplot2) # plotting # main plot scatter &lt;- ggplot(SpeedSki, aes(Year, Speed)) + geom_point() # show with trimmings scatter + labs(x = &quot;Birth Year&quot;, y = &quot;Speed Achieved (km/hr)&quot;) + ggtitle(&quot;Ninety-One Skiers by Birth Year and Speed Achieved&quot;) ggplot2 permets de créer facilement des scatterplots. En utilisant geom_point(), vous pouvez aisément afficher deux types différents d’aesthetic en un graphique. C’est aussi très simple de les personnaliser pour les rendre plus jolis (tout ce qui est vraiment nécessaire c’est les données, l’aesthetic et la geom). 12.4 Théorie Les scatterplots sont vraiment utiles pour comprendre les correlations (ou pas) entre des variables. Par exemple dans la section 13.2 vous pourrez remarquer la correlation positive entre le poids du cerveau et le poids du corps des differentes espèces de mammifères terrestres. Le scatterplot donne généralement une bonne idée pour savoir si un corrélation est positive ou négative (si tant est qu’elle existe). Néanmoins il ne faut pas confondre corrélation et causalité dans un scatterplot ! Ci-dessous, différentes variations sur les scatterplots qui peuvent être utilisé pour améliorer l’interpretabilité. Pour plus d’info sur comment ajouter des lignes, contours, comparer des grouper et afficher des variables continues regarder Chapter 5 du livre. 12.5 Quand utiliser ? Les scatterplots sont bien pour étudier les liens entre les différentes variables. Fondamentalement, si vous vous interessez au lien qui unissent différentes variables, les scatterplots sont un bon point de départ. 12.6 Considérations 12.6.1 Chevauchement des données. Les données avec des valeurs similaires vont se chevaucher dans un scatterplot et cela peut conduire à des problèmes. Vous pourrez pour cela au choix essayer le alpha blending ou le jittering (liens vers le chevauchement de la section sur Iris Walkthrough). 12.6.2 Changement d’échelle N’oubliez pas que le changement d’échelle peut modifier la perception des données : library(ggplot2) num_points &lt;- 100 wide_x &lt;- c(rnorm(n = 50, mean = 100, sd = 2), rnorm(n = 50, mean = 10, sd = 2)) wide_y &lt;- rnorm(n = num_points, mean = 5, sd = 2) df &lt;- data.frame(wide_x, wide_y) ggplot(df, aes(wide_x, wide_y)) + geom_point() + ggtitle(&quot;Linear X-Axis&quot;) ggplot(df, aes(wide_x, wide_y)) + geom_point() + ggtitle(&quot;Log-10 X-Axis&quot;) + scale_x_log10() 12.7 Modifications 12.7.1 Lignes de contours Les lignes de contour donnent en un regard une compréhension de la densité.. Pour ces contour maps, on va utiliser le jeu de données SpeedSki. Les lignes de contour peuvent être afficher en utilisant geom_density_2d(): ggplot(SpeedSki, aes(Year, Speed)) + geom_density_2d() Les lignes de contour marchent d’autant mieux lorsqu’elles sont combinées aux autres couches : ggplot(SpeedSki, aes(Year, Speed)) + geom_point() + geom_density_2d(bins = 5) 12.7.2 Matrices de scatterplot Si vous souhaitez comparer de multiples paramètres les uns par rapport aux autres vous pourrez untiliser une matrice de scatterplots. Cela vous permettra de mettre en exergue de multiples comparaisons de façon compact et efficaces. Pour ces matrices de scatterplot, on va utiliser le jeu de données movies du package ggplot2movies. Par défaut la fonction R de base plot() crée une matrice de scatterplots lorsque de multiples variables sont données en entrée : library(ggplot2movies) # data library(dplyr) # manipulation index &lt;- sample(nrow(movies), 500) #sample data moviedf &lt;- movies[index,] # data frame splomvar &lt;- moviedf %&gt;% dplyr::select(length, budget, votes, rating, year) plot(splomvar) Bien que cela peut être très utile lors d’une exploration personnelle des données, ce n’est pas recommender pour une présentation. L’Hermann grid illusion rend ces graphiques très durs à examiner. Pour palier ce problème, utilisez la fonction splom() du package lattice : library(lattice) #sploms splom(splomvar) 12.8 Ressources externes Quick-R article sur les scatterplots de base en R. Du simple au plus sophistiqué avec notamment des matruces, de la haut densité et des versions 3D STHDA Base R: article sur les scatterplots de base en R. Plus d’exmple pour améliorer un graphe. STHDA ggplot2: articles sur les scatterplots via ggplot2. Très bon pour le formattage et les options dispoinibles pour le facetting. Stack Overflow sur comment labeliser des points avec geom_point() ggplot2 cheatsheet: Toujours bon d’y jeter un oeil. "],
["iris.html", "13 Walkthrough: Iris Scatterplot 13.1 Avant-propos 13.2 Petite note sur comment le faire sans effort 13.3 Visualisation des données 13.4 Afficher les données 13.5 Markdown etiquette 13.6 Chevauchement de données 13.7 Remanier pour présenter 13.8 Modifier l’apparence 13.9 Ajouter des themes 13.10 Pour aller plus loin 13.11 Liens utiles", " 13 Walkthrough: Iris Scatterplot 13.1 Avant-propos Cet exemple s’intéresse au jeu de données iris et s’achève par la construction d’un scatterplot présentable. 13.1.1 tl;dr Voilà ce à quoi on doit aboutir : library(ggplot2) base_plot &lt;- ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Sepal.Width)) + geom_point(aes(color = Species), size = 3, alpha = 0.5, position = &quot;jitter&quot;) + xlab(&quot;Sepal Length (cm)&quot;) + ylab(&quot;Sepal Width (cm)&quot;) + ggtitle(&quot;Sepal Dimensions in Different Species of Iris Flowers&quot;) base_plot + theme_minimal() Tu te demandes comment on est arrivé là ? Tu peux jeter un oeil à 13.1.2 Packages ggplot2 dplyr stats Base datasets (gridExtra) 13.1.3 Techniques On te les laisse en anglais par cohérence avec le cours et les recherches que tu pourras faire sur Google Keyboard Shortcuts Viewing Data Structure/Dimensions/etc. Accessing Documentation Plotting with ggplot2 Layered Nature of ggplot2/Grammar of Graphics Mapping aesthetics in ggplot2 Overlapping Data: alpha and jitter Presenting Graphics Themes 13.2 Petite note sur comment le faire sans effort Les raccourcis sont tes meilleurs amis pour aller plus vite. Et en plus ils sont faciles à trouver. Dans la barre principale : Tools &gt; Keyboard Shortcuts Help OR ⌥⇧K Quelques bons raccourcis : Insérer un opérateur d’assignation (&lt;-): Alt/Option+- Insérer un (%&gt;%): Ctrl/Cmd+Shift+M Mettre un commentaire : Ctrl/Cmd+Shift+C Lancer la ligne ou la sélection : Ctrl/Cmd+Enter Relancer la cellule d’avant : Ctrl/Cmd+Shift+P Restez attentif à chose que vous faites tout le temps et demander vous si vous ne pourriez pas le faire plus rapidement. En outre, l’IDE RStudio peut se montrer intimidant, mais il est rempli de petits outils que vous pourrez lire sur cette cheatsheet ou bien sur un des cours de DataCamp : Part 1, Part 2. Okay, maintenant on est parti… 13.3 Visualisation des données Commençons par charger le package, ainsi on pourra récupérer les données dans un dataframe. library(datasets) class(iris) ## [1] &quot;data.frame&quot; Ce n’est pas un très grand jeu de données, mais c’est utile de prendre l’habitude de considérer un jeu de données comme lourd quoi qu’il arrive. Par conséquent avant d’afficher le jeu de données dans le terminal soyez certain d’avoir regarder la taille et la structure de données de votre jeu de données. Ici on peut voir qu’on a 150 observations sur 5 variables différentes. dim(iris) ## [1] 150 5 Il y a plein de façon d’avoir les infos sur votre jeu de données, en voici quelques uns : str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## # This one requires dplyr, but it&#39;s worth it :) library(dplyr) glimpse(iris) ## Observations: 150 ## Variables: 5 ## $ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5… ## $ Sepal.Width &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3… ## $ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1… ## $ Petal.Width &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0… ## $ Species &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, set… Afficher les données en appelant iris dans le terminal affichera la totalité. Allez-y dans ce cas précis vous pouvez essayer, mais ce n’est pas recommendé pour les jeux de données plus large. Au contraire vous pouvez utiliser head() ou bien View() dans le terminal. Si vous souhaitez en apprendre plus sur une commande, tapez juste ?&lt;command&gt; dans le terminal. Par exemple ?head vous apprendra que la fonction head dispose d’un argument supplémentaire n pour le nombre de lignes que vous souhaitez afficher (par défaut égal à 6). Aussi remarquerez vous peut-être qu’il y a quelque chose appelé tail. Je me demande à quoi ça sert ! 13.4 Afficher les données Affichons quelque chose ! # Something&#39;s missing library(ggplot2) ggplot(iris) Où est-ce que c’est ? Peut-être que si nous ajoutons quelques aesthetics… Je me rappelle avoir entendu ce mot important quelque part : # Still not working... ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Sepal.Width)) Toujours rien. Rappelez-vous que qu’il faut ajouter une geom pour afficher quelque chose. # There we go! ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() Houra ! Quelque chose s’est affiché ! Faites attention à où nous avons mis les données, à l’intérieur de ggplot(). ggplot est composé de couches et ici nous avons mis les données dans la fonction principale de ggplot. L’argument data est aussi disponible dans geom_point(), mais cela ne s’appliquera qu’à cette couche précise. Ici nous avons fixé que sans précisions supplémentaire l’argument data sera iris. Maintenant ajoutons un peu de couleur par Species : ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Sepal.Width)) + geom_point(aes(color = Species)) Générallement c’est utile de stocker la majeure partie du graphique dans une variable et ensuite d’y ajouter des couches. Le code ci-dessous réalise le même travail qu’au dessus : sepal_plot &lt;- ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Sepal.Width)) sepal_plot + geom_point(aes(color = Species)) 13.5 Markdown etiquette Je remarque que mon fichier R Markdown est un peu en bazar. On peut rapidement perdre le controle d’un fichier Rmd mais ils y a quelques astuces pour ça. La première chose, donnez des noms à vos chunks. Si en plus vous combinez ça avec des entêtes le travaille sera mieux organisé. Plus particulièrement la petite ligne en bas de l’éditeur à toute son utilité. De ça : A ça : Ajoutez un nom au début de chaque chunk : {r &lt;cool-code-chunk-name&gt;, &lt;chunk_option&gt; = TRUE} Maintenant on est capable de savoir de quoi parle la chunk et où on en est dans le document. N’oubliez pas, il faut un espace après le r et une virgule entre chaque option telle que eval ou echo. Pour plus d’info voir notre section pour communique des résultats. 13.6 Chevauchement de données Ceux qui ont un compas dans l’oeil auront remarqué mais quelques points ont disparus. On devrait avoir 150 points, pour autant on en voit que 117 (oui oui je les ai compté). Où sont passés les 33 points manquants ? En fait, ils sont cachés derrières d’autres points. Le jeu de données arrondi au dixième de centimètre prêt ce qui nous donne ce placement des points si régulier. Comment je sais que c’est en centimètres ? J’ai fait ?iris dans le terminal mon cher Watson ! Ah, question bête, réponse bête. # This plot hides some of the points ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Sepal.Width)) + geom_point(aes(color = Species)) Qui est le coupable ? L’aesthetic color. La couleur par défaut est opaque et cachera tous les points qui sont derrière. En règle générale c’est toujours bénéfique de réduire l’opacité un petit peu pour éviter ce problème. Pour faire ça changer la valeur de alpha pour quelque chose différent de 1, par exemple 0.5. ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Sepal.Width)) + geom_point(aes(color = Species, alpha = 0.5)) Okay… Plusieurs choses. 13.6.1 Premièrement : la légende Premièrement, avez-vous remarqué l’ajout soudain de la légende ? C’est idiot ! Pourquoi c’est apparu comme ça ? En fait, lorsqu’on a ajouté alpha dans aes() cela a généré une légende. Regardons plus en détail geom_point(). Plus particulièrement cela nous montre où on doit préciser color et alpha : geom_point(mapping = aes(color = Species, alpha = 0.5)) Donc on associe ces aesthtics color and alpha, à certains valeurs. ggplot sait que généralement cette association va varier étant donné que vous êtes en train de travailler sur des données qui elles-mêmes varient. C’est pourquoi il va créer une légende pour chaque association. Néanmoins pour le alpha on a pas besoin de légende on l’a fixé à 0.5. Si on veut changer ça, il suffit de mettre alpha à l’exterieur de l’aes et le traiter comme un argument : ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Sepal.Width)) + geom_point(aes(color = Species), alpha = 0.5) Plus de légende. Donc sur ggplot on obtient pas le même résultat suivant où est placé l’aesthetic. C’est ce qu’on appelle le MAPPING d’aesthetic (faire varier avec des données à l’intérieur de aes) ou le SETTING d’aesthetic (le rendre constant sur tous les points en plaçant le paramètre à l’éxterieur de aes). 13.6.2 Deuxièment : le jittering Deuxièment, est-ce que l’astuce du alpha nous a vraiment aidé ? Est-ce qu’on est capable de véritablement voir les choses plus facilement ? Pas vraiment… Comme les points se chevauche parfaitement, l’opacité ne nous aide pas tant que ça. Habituellement l’opacité marche mais ici les données sont si régulières que ça n’améliore pas leur perception. On peut régler ça en ajoutant du jitter au points. Le Jitter ajoute un bruit aléatoire aux points et les bougent de sorte qu’ils ne se chevauchent plus entièrement : ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Sepal.Width)) + geom_point(aes(color = Species), alpha = 0.5, position = &quot;jitter&quot;) Utilisez le jittering avec modération et n’oubliez pas que vous altérer les données. Néanmoins dans certaines situations c’est très utile. 13.6.3 Parenthèse : Exemple de cas où le alpha blending est utile Nous avons vu un cas où le jittering marchait très bien, alors que le alpha ne nous aidait pas plus que ça. Voyons maintenant un exemple où l’opacité et le changement du alpha sera directement utile. # lib for arranging plots side by side library(gridExtra) # make some normally distributed data x_points &lt;- rnorm(n = 10000, mean = 0, sd = 2) y_points &lt;- rnorm(n = 10000, mean = 6, sd = 2) df &lt;- data.frame(x_points, y_points) # plot with/without changed alpha plt1 &lt;- ggplot(df, aes(x_points, y_points)) + geom_point() + ggtitle(&quot;Before (alpha = 1)&quot;) plt2 &lt;- ggplot(df, aes(x_points, y_points)) + geom_point(alpha = 0.1) + ggtitle(&quot;After (alpha = 0.1)&quot;) # arrange plots gridExtra::grid.arrange(plt1, plt2, ncol = 2, nrow = 1) Ici, c’est plus simple de voir que le jeu de données est très concentré. 13.7 Remanier pour présenter Disons que nous avons fini notre graphique et que nous sommes prêt à le présenter à d’autres gens : We should clean it up a bit so it can stand on its own. 13.8 Modifier l’apparence Premièrement, rendons les noms des axes x/y plus clairs et descriptifs : ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Sepal.Width)) + geom_point(aes(color = Species), alpha = 0.5, position = &quot;jitter&quot;) + xlab(&quot;Sepal Length (cm)&quot;) + ylab(&quot;Sepal Width (cm)&quot;) Ensuite, mettons un titre : ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Sepal.Width)) + geom_point(aes(color = Species), alpha = 0.5, position = &quot;jitter&quot;) + xlab(&quot;Sepal Length (cm)&quot;) + ylab(&quot;Sepal Width (cm)&quot;) + ggtitle(&quot;Sepal Dimensions in Different Species of Iris Flowers&quot;) Et grossissons les point : ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Sepal.Width)) + geom_point(aes(color = Species), size = 3, alpha = 0.5, position = &quot;jitter&quot;) + xlab(&quot;Sepal Length (cm)&quot;) + ylab(&quot;Sepal Width (cm)&quot;) + ggtitle(&quot;Sepal Dimensions in Different Species of Iris Flowers&quot;) Maintenant c’est présentable ! 13.9 Ajouter des themes Il sera dans certaine situation mieux de changer les theme de votre graphique (l’arrière-plan, les axes, “accessories” etc.). Jetez un oeil aux différents thèmes qui existent et choisissez en un qui vous plait. base_plot &lt;- ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Sepal.Width)) + geom_point(aes(color = Species), size = 3, alpha = 0.5, position = &quot;jitter&quot;) + xlab(&quot;Sepal Length (cm)&quot;) + ylab(&quot;Sepal Width (cm)&quot;) + ggtitle(&quot;Sepal Dimensions in Different Species of Iris Flowers&quot;) base_plot base_plot + theme_light() base_plot + theme_minimal() base_plot + theme_classic() base_plot + theme_void() Cette fois je vais utilisé theme_minimal(). Nous y voilà ! Nous avons un scatterplot prêt à conquérir le monde ! 13.10 Pour aller plus loin Nous n’avons que toucher la surface de ggplot et toucher du doigt la grammaire des graphiques. Si vous souhaitez aller plus loin, je vous recommende hautement les cours de DataCamp Data Visualization with ggplot2 de Rick Scavetta. Ce cours est en 3 parties très denses, mais la première partie vaut vraiment le détour. 13.11 Liens utiles RStudio ggplot2 Cheat Sheet DataCamp: Mapping aesthetics to things in ggplot R Markdown Reference Guide R for Data Science "],
["parallelcoordinates.html", "14 Chart: Parallel Coordinate Plots 14.1 Vue d’ensemble 14.2 tl;dr 14.3 Examples simples 14.4 Theorie 14.5 Quand les utiliser 14.6 Considerations 14.7 Modifications 14.8 Autres Packages 14.9 Ressources Externes", " 14 Chart: Parallel Coordinate Plots Ce chapitre était initialement une contribution à la communauté de aashnakanuga 14.1 Vue d’ensemble Cette secion couvre comment créer des graphiques à coordonnées parallèles statiques avec le package GGally. Pour des graphiques à coordonnées parallèles interactifs, voir le package parcoords . Le package vignette donne des instructions pour l’utilisation de ce package. 14.2 tl;dr Je veux un bel example! Pas demain, pas après le petit déjeuner, MAINTENANT! Observons l’effet des différents attributs sur chaque coupe “Fair” de diamond du jeu de données “diamonds”: Et voici le code: library(GGally) library(dplyr) #subset the data to get the first thousand cases diamonds_subset &lt;- subset(diamonds[1:1000,]) #rename the variables to understand what they signify names(diamonds_subset)&lt;-c(&quot;carat&quot;,&quot;cut&quot;,&quot;color&quot;,&quot;clarity&quot;,&quot;depth_percentage&quot;,&quot;table&quot;,&quot;price&quot;,&quot;length&quot;,&quot;width&quot;,&quot;depth&quot;) #Create a new column to highlight the fair cut diamonds ds_fair&lt;-within(diamonds_subset, diamond_cut&lt;-if_else(cut==&quot;Fair&quot;, &quot;Fair&quot;, &quot;Other&quot;)) #Create the graph ggparcoord(ds_fair[order(ds_fair$diamond_cut, decreasing=TRUE),], columns=c(1,5,7:10), groupColumn = &quot;diamond_cut&quot;, alphaLines = 0.8, order=c(5,1,8,9,10,7), title = &quot;Parallel Coordinate Plot showing trends for Fair cut diamonds&quot;, scale = &quot;uniminmax&quot;) + scale_color_manual(values=c(&quot;maroon&quot;,&quot;gray&quot;)) Pour plus d’informations sur ce jeu de données, tapez ?diamonds dans la console. 14.3 Examples simples Du calme! Trop compliqué! Beacoup plus facile, s’il-vous-plaît. Utilisons le jeu de données “iris” pour cet exemple: library(datasets) library(GGally) ggparcoord(iris, columns=1:4, title = &quot;Parallel coordinate plot for Iris flowers&quot;) Pour plus d’informations sur ce jeu de données, tapez ?iris dans la console. 14.4 Theorie Pour plus d’informations sur les graphiques à coordonnées parallèles et les données continues multivariées, regarder le Chapitre 6 du livre de cours. 14.5 Quand les utiliser En général, les graphiques à coordonnées parallèles sont utilisés pour déduire des liens entre plusieurs variables continues - onles utilise en général pour detecter une tendance que nos données suivent, et les cas particuliers que sont les Generally, parallel coordinate plots are used to infer relationships between multiple continuous variables - we mostly use them to detect a general trend that our data follows, and also the specific cases that are valeurs aberrantes (outliers). Veuillez garder à l’esprit que les graphiques à coordonnées parallèles ne sont pas idéaux quand il n’y a que des données catégoriques. Nous pouvons inclure quelques variables catégoriques de nos axes dans un souci de clustering, mais utiliser beaucoup de variables catégorique cause une saturation du graphique, ce qui le rend moins interprétable. Nous utilisons aussi les graphiques à coordonnées parallèles pour identifier les tendances dans des clusters particuliers - pour illustrer chaque cluster dans une couleur différente, utiliser l’attribut groupColumn de ggparcoord(), specifiez votre colonne, et c’est parti! Parfois, les graphiques à coordonnées parallèles sont utiles pour les séries temporelles - quand nous avons des informations enregistrées à des intervalles de temps réguliers. Chaque axe vertical sera desormais un point temporel et nous passerons cette colonne en attribut “column” pour ggparcoord. 14.6 Considerations 14.6.1 Quand utiliser le clustering? En général, on utilise le clustering quand on veut observer un motif récurrent dans des données catégoriques avec des propriétés spécifiques. On divise les variables en clusters selon leur valeur spécifique pour une certaine variable catégorique. On peut également utiliser une variable continue; en la transformant en variable catégorique. Par exemple, en divisant les valeurs possibles selons deux cas: pour une variable continue taille: on divise en ceux dont la taille est supérieure à 150cm et ceux pour lesquels ça n’est pas le cas. Regardons un exemple avec le dataset iris, en clusterisant la colonne “Species”: library(GGally) #highlight the clusters based on the Species column graph&lt;-ggparcoord(iris, columns=1:4, groupColumn = 5, title = &quot;Plot for Iris data, where each color represents a specific Species&quot;) graph 14.6.2 Choix du paramètre alpha En pratique, les graphiques à coordonnées parallèles ne sont pas utiles pour des petits jeux de données. Il est plus probable que vos données soient constituées de milliers de cas différents, et il est parfois difficile d’interpréter un graphique à coordonnées parallèles quand autant de cas se recoupent. Pour résoudre ce problème, on définit le paramètre alphalines avec une valeur entre 0 et 1. Ce paramètre réduit l’opacité des lignes pour qu’on puisse mieux comprendre ce qui se passe quand beaucoup de cas se recoupent. On utilise à nouveau le jeu de données iris, mais en réduisant le paramètre alpha à 0.5. Regardez comme il est beaucoup plus facile de suivre le cours de chaque cas: library(ggplot2) library(GGally) #set the value of alpha to 0.5 ggparcoord(iris, columns=1:4, groupColumn = 5, alphaLines = 0.5, title = &quot;Iris data with a lower alpha value&quot;) 14.6.3 Scales Quand on utilise ggparcoord(), on peut définir l’attribut scale, qui met à la même échelle toutes les variables pour qu’on puisse comparer leurs valeurs simplement. Les différents types d’échelle sont: std: valeur par défaut, on soustrait la moyenne et on divise par l’écart-type robust: on soustrait la mediane et on devise par l’ecart absolu de la médiane (median absolute deviation) uniminmax: on met à l’échelle toutes les valeurs pour que le minimum soit à 0 et le maximum à 1 globalminmax: pas de mise à l’échelle, on garde les valeurs d’origine center: On centre chaque variable selon sa valeur donnée par scaleSummary centerObs: on centre chaque variable selon sa valeur donnée par centerObsID Créons un échantillon de données et observons comment les valeurs sur l’axe des y changent pour chaque échelle: library(ggplot2) library(GGally) library(gridExtra) #creating a sample dataset df1&lt;-data.frame(col1=c(11,4,7,4,3,8,5,7,9), col2=c(105,94,138,194,173,129,156,163,148)) #pay attention to the different values on the y-axis g1&lt;-ggparcoord(df1, columns=1:2, scale = &quot;std&quot;, title = &quot;Standard Scale&quot;) g2&lt;-ggparcoord(df1, columns=1:2, scale = &quot;robust&quot;, title = &quot;Robust Scale&quot;) g3&lt;-ggparcoord(df1, columns=1:2, scale = &quot;uniminmax&quot;, title = &quot;Uniminmax Scale&quot;) g4&lt;-ggparcoord(df1, columns=1:2, scale = &quot;globalminmax&quot;, title = &quot;Globalminmax Scale&quot;) g5&lt;-ggparcoord(df1, columns=1:2, scale = &quot;center&quot;, scaleSummary = &quot;mean&quot;, title = &quot;Center Scale&quot;) g6&lt;-ggparcoord(df1, columns=1:2, scale = &quot;centerObs&quot;, centerObsID = 4, title = &quot;CenterObs Scale&quot;) grid.arrange(g1, g2, g3, g4, g5, g6, nrow=2) 14.6.4 Ordre des variables Le choix de l’ordre des variables sur l’axe des y dépend de l’application. Il peut être spécifié avec le paramètre order. Les différents types d’ordre sont: default: l’ordre dans lequel nous ajoutons nos variables à l’attribut column given vector: on donne un vecteur contenant l’ordre dont on a besoin (cas le plus fréquent) anyClass: l’ordre basé sur la séparation d’une variable des autres (F-statistic - chaque variable v/s le reste) allClass: l’ordre basé sur la variation entre les classes (F-statistic - groupe column v/s le reste) skewness: l’ordre du plus au moins dévié (skewed) Outlying: l’orre basé sur la valeur de Outlying 14.7 Modifications 14.7.1 Permutation des coordonnées C’est une bonne idée quand on a trop de variables et que leurs noms se chevauchent sur l’axe des x: library(ggplot2) library(GGally) #using the iris dataset graph + coord_flip() 14.7.2 Faire appparaître des tendances Voyons quelle tendance suit l’espèce Versicolor du jeu de données iris par rapport aux autres variables: library(ggplot2) library(GGally) library(dplyr) #get a new column that says &quot;Yes&quot; of the Species is versicolor. ds_versi&lt;-within(iris, versicolor&lt;-if_else(Species==&quot;versicolor&quot;, &quot;Yes&quot;, &quot;No&quot;)) ggparcoord(ds_versi[order(ds_versi$versicolor),], columns = 1:4, groupColumn = &quot;versicolor&quot;, title = &quot;Highlighting trends of Versicolor species&quot;) + scale_color_manual(values=c(&quot;gray&quot;,&quot;maroon&quot;)) 14.7.3 Utilisation de splines En général, one utilise les splines quand on a une colonne dans laquelle beaucoup de valeurs se répètent, ce qui ajoute beaucoup de bruit. Les lignes de spline deviennent de plus en plus incurvées quand on choisit un facteur spline élevé, ce qui retire du bruit et rend l’observation de tendances plus facile. Il peut être défini en utilisant l’attribut splineFactor : library(ggplot2) library(GGally) library(gridExtra) #create a sample dataset df2&lt;-data.frame(col1=c(1:9), col2=c(11,11,14,15,15,15,17,18,18), col3=c(4,4,4,7,7,7,8,9,9), col4=c(3,3,3,4,6,6,6,8,8)) #plot without spline g7&lt;-ggparcoord(df2, columns = 1:4, scale = &quot;globalminmax&quot;, title = &quot;No Spline factor&quot;) #plot with spline g8&lt;-ggparcoord(df2, columns = 1:4, scale = &quot;globalminmax&quot;, splineFactor=10, title = &quot;Spline factor set to 10&quot;) grid.arrange(g7,g8) 14.7.4 Ajout de boxplot au graphique You can add boxplots to your graph, which can be useful for observing the trend of median values. Generally, they are added to data with a lot of variables - for example, if we plot time series data. Vous pouvez ajouter des boxplots à votre graphique. C’est utile pour observer la tendance de la médiane des valeurs. En général, on les ajoute aux données avec beaucoup de variables - par exemple, les séries temporelles. 14.8 Autres Packages Il y a une multitude d’autres packages qui ont des fonctions pour créer des graphiques à coordonnées parallèles: [à faire: ajouter des liens] parcoords::parcoords() – une bonne solution interactive ggplot2::geom_line() – n’est pas propre aux graphiques à coordonnées parallèles, mais sont faciles à créer avec le paramètre group=. lattice::parallelplot() MASS::parcoord() 14.9 Ressources Externes Introduction to parallel coordinate plots: Très bonne ressource qui donne des détails pour chaque attribut et chaque valeur possible. Possède de bons exemples. How to create interactive parallel coordinate plots: explique bien comment utiliser plotly pour créer un diagramme à coordonnées parallèles interactif. Different methods to create parallel coordinate plots: Uniquement quand on a des variables categoriques. "],
["mosaic.html", "15 Diagramme : Mosaic 15.1 Vue d’ensemble 15.2 tl;dr 15.3 L’ordre des coupes 15.4 Direction des coupes 15.5 Couleur 15.6 Etiquettes 15.7 Agencement des cellules 15.8 Mosaique en utilisant ggplot 15.9 Théorie 15.10 Quand l’utiliser 15.11 Considerations 15.12 Ressources externes", " 15 Diagramme : Mosaic Ce chapitre est issu d’une contribution à la communauté crée par harin Cette page est en cours de mise à jour. Nous apprécions toute remarque que vous puissiez avoir. Pour nous aider à améliorer cette page, vous pouvez contribuer à notre repo. 15.1 Vue d’ensemble Cette section explique comment faire des graphiques en Mosaïque (Mosaic Plots) 15.2 tl;dr library(vcd) mosaic(Favorite ~ Age + Music, labeling = labeling_border( abbreviate_labs = c(3, 10, 6), rot_labels=c(0,0,-45) ), direction=c(&#39;v&#39;,&#39;v&#39;,&#39;h&#39;), # Age = Vertical, Music = Vertical, Favoriate = Horizonal (a.k.a DoubleDecker) gp = gpar(fill=c(&#39;lightblue&#39;, &#39;gray&#39;)), df) 15.3 L’ordre des coupes Il est préférable de dessiner des graphiques en mosaïque de façon incrémentale: commencez en coupant selon une variable, puis ajoutez des variables une par une. Le graphique en mosaïque complet devrait avoir une seule coupe par variable. Important: si vos données sont dans un data frame, comme c’est le cas ci-dessous, la colonne count doit être appellée Freq. (Aussi valable pour les tables et les matrices, voir ?vcd::structable pour plus de détails.) Veuillez aussi noter que ces graphiques sont dessinés avec vcd::mosaic() et non la fonction en R élémentaire, mosaicplot(). Les données: df ## Age Favorite Music Freq ## 1 old bubble gum classical 1 ## 2 old bubble gum rock 1 ## 3 old coffee classical 3 ## 4 old coffee rock 1 ## 5 young bubble gum classical 2 ## 6 young bubble gum rock 5 ## 7 young coffee classical 1 ## 8 young coffee rock 0 Coupe uniquement selon Age: library(vcd) mosaic(~Age, df) Coupe selon Age, puis Music: mosaic(Music ~ Age, df) Notez que la première coupe est entre “young” et “old”, tandis que la deuxième série de coupes divise chaque groupe d’âge entre “classical” et “rock”. Coupe selon Age, puis Music, puis Favorite: mosaic(Favorite ~ Age + Music, df) 15.4 Direction des coupes Notez que dans l’exemple précédent, la direction des coupes est faite comme suit: Age – coupe horizontale Music – coupe verticale Favorite – coupe horizontale Il s’agit du schéma usuel de direction de coupes: les directions alternent en commençant par une coupe horizontale. On en déduit le même graphique avec: mosaic(Favorite ~ Age + Music, direction = c(&quot;h&quot;, &quot;v&quot;, &quot;h&quot;), df) Les directions peuvent être modifiées comme comme vous le souhaitez. Par exemple, pour créer un graphique de type “doubledecker”, toutes les coupes doivent être verticales sauf la dernière: mosaic(Favorite ~ Age + Music, direction = c(&quot;v&quot;, &quot;v&quot;, &quot;h&quot;), df) Notez que le vecteur des directions est ordonné selon l’ordre des coupes (Age, Music, Favorite), et non selon l’ordre dans lequel les variables apparaissent dans la formule, où la dernière variable à être coupée apparaît en premier dans la formule, avant le “~”. 15.5 Couleur 15.5.1 Couleur de fond library(grid) # needed for gpar mosaic(Favorite ~ Age + Music, gp = gpar(fill = c(&quot;lightblue&quot;, &quot;blue&quot;)), df) 15.5.2 Couleur de bordure (il faut également définir la couleur de fond(?)) mosaic(Favorite ~ Age + Music, gp = gpar(fill = c(&quot;lightblue&quot;, &quot;blue&quot;), col = &quot;white&quot;), spacing = spacing_equal(sp = unit(0, &quot;lines&quot;)), df) 15.6 Etiquettes Pour la documentation officielle sur les options d’étiquettage, voir Labeling in the Strucplot Framework 15.6.1 Faire pivoter les étiquettes Le vecteur rot_labels = définit la rotation en degrés sur les quatre côtés du graphique–pas selon l’ordre de coupe des variables–dans cet ordre: haut, droite, bas, gauche. (C’est un ordre différent de l’ordre par défaut des graphiques élémentaires!) L’ordre par défaut est rot_labels = c(0, 90, 0, 90). mosaic(Favorite ~ Age + Music, labeling = labeling_border(rot_labels = c(45, -45, 0, 0)), df) 15.6.2 Alléger les étiquettes Les étiquettes sont abrégées dans l’ordre des coupes (comme avec direction =). L’algorithme d’abbréviation renvoit le nombre indiqué de charactères après suppression des voyelles (si nécessaire). Pour plus d’options sur le format, voir &gt;?vcd::labeling_border. mosaic(Favorite ~ Age + Music, labeling = labeling_border(abbreviate_labs = c(3, 1, 6)), df) 15.7 Agencement des cellules mosaic(Favorite ~ Age + Music, spacing = spacing_equal(sp = unit(0, &quot;lines&quot;)), df) Pour plus de détails, voir &gt;?vcd::spacings 15.7.1 Mosaïque en utilisant vcd::doubledecker data(Arthritis) vcd::doubledecker(Improved ~ Treatment + Sex, data=Arthritis) vcd::doubledecker(Music ~ Favorite + Age, xtabs(Freq ~ Age + Music + Favorite, df)) 15.8 Mosaique en utilisant ggplot Pour avoir une vue d’ensemble sur les graphiques en mosaïques avec ggplot, voir le lien ci-dessous. https://cran.r-project.org/web/packages/ggmosaic/vignettes/ggmosaic.html library(ggmosaic) # equivalent to doing Favorite ~ Age + Music in vcd::mosaic with doubledecker style cut ggplot(df) + geom_mosaic( aes(x=product(Favorite, Age, Music), # cut from right to left weight=Freq, fill=Favorite ), divider=c(&quot;vspine&quot; , &quot;hspine&quot;, &quot;hspine&quot;) # equivalent to divider=ddecker() ) 15.9 Théorie 15.10 Quand l’utiliser Quand vous voulez étudier les liens entre les variables d’un jeu de données Catégoriques Multivariées 15.11 Considerations 15.11.1 Etiquettes La lisibilité des étiquettes pose problème dans les graphiques en mosaïque, particulièrement quand il y a beaucoup de dimensions. Ceci peut être allégé en - Racourcissant les noms - Faisant pivoter les étiquettes 15.11.2 Aspect Ratio Les longueurs sont plus faciles à évaluer que les aires. Essayez d’utiliser des rectangles de même épaisseur ou hauteur Les rectangles longs et fins sont préférables (on distinge plus facilement les longueurs que les aires) 15.11.3 Espace entre les rectangles Pas d’espace = le plus efficace Néanmoins, un espace peut améliorer la lisibilitén donc essayez différentes combinaisons. On peut avoir des espaces au niveau des coupes On peut faire varier la taille des espaces selon la hierarchie 15.11.4 Couleur bien pour les rapports dans le sous-groupe Affiche les groupes résiduels met en avant un sous-groupe particulier 15.12 Ressources externes Chapitre 7 de Graphical data analysis with R by Anthony Unwin Lien: Une vue d’ensemble des graphiques en mosaïque avec ggplot au lien ci-joint. "],
["heatmap.html", "16 Diagramme: Carte Thermique 16.1 Vue d’ensemble 16.2 tl;dr 16.3 Exemples simples 16.4 Theorie 16.5 Ressources Externes", " 16 Diagramme: Carte Thermique 16.1 Vue d’ensemble Cette section explique comment faire des cartes thermiques. 16.2 tl;dr J’en ai assez de ces exemples trop faciles! Je veux un exemple compliqué! Voici une carte thermique des catégories sociales des fils et pères aux Etat-Unis, au Royaume-Uni, et au Japon: Et voici le code: library(vcdExtra) # dataset library(dplyr) # manipulation library(ggplot2) # plotting library(viridis) # color palette # format data orderedclasses &lt;- c(&quot;Farm&quot;, &quot;LoM&quot;, &quot;UpM&quot;, &quot;LoNM&quot;, &quot;UpNM&quot;) mydata &lt;- Yamaguchi87 mydata$Son &lt;- factor(mydata$Son, levels = orderedclasses) mydata$Father &lt;- factor(mydata$Father, levels = orderedclasses) japan &lt;- mydata %&gt;% filter(Country == &quot;Japan&quot;) uk &lt;- mydata %&gt;% filter(Country == &quot;UK&quot;) us &lt;- mydata %&gt;% filter(Country == &quot;US&quot;) # convert to % of country and class total mydata_new &lt;- mydata %&gt;% group_by(Country, Father) %&gt;% mutate(Total = sum(Freq)) %&gt;% ungroup() # make custom theme theme_heat &lt;- theme_classic() + theme(axis.line = element_blank(), axis.ticks = element_blank()) # basic plot plot &lt;- ggplot(mydata_new, aes(x = Father, y = Son)) + geom_tile(aes(fill = Freq/Total), color = &quot;white&quot;) + coord_fixed() + facet_wrap(~Country) + theme_heat # plot with text overlay and viridis color palette plot + geom_text(aes(label = round(Freq/Total, 1)), color = &quot;white&quot;) + scale_fill_viridis() + # formatting ggtitle(&quot;Like Father, Like Son&quot;, subtitle = &quot;Heatmaps of occupational categories for fathers and sons, by country&quot;) + labs(caption = &quot;Source: vcdExtra::Yamaguchi87&quot;) + theme(plot.title = element_text(face = &quot;bold&quot;)) + theme(plot.subtitle = element_text(face = &quot;bold&quot;, color = &quot;grey35&quot;)) + theme(plot.caption = element_text(color = &quot;grey68&quot;)) Pour plus d’informations sur ce jeu de données, tapez ?vcdExtra::Yamaguchi87 dans la console. 16.3 Exemples simples Trop compliqué! Simplifie, mon pote! 16.3.1 Carte thermique de compartiments d’histogrammes en 2D (bin count) Pour cette carte thermique, nous utiliserons le jeu de données SpeedSki. Seulement deux variables, x et y sont nécessaires pour des cartes thermiques de bin count en 2D. La troisième variable–i.e., la couleur–represente le bin count de points dans la région qu’elle recouvre. Imaginez un histogramme en 2D. Pour créer une carte thermique, il suffit ed remplacer geom_point() par geom_bin2d(): library(ggplot2) # plotting library(GDAdata) # data (SpeedSki) ggplot(SpeedSki, aes(Year, Speed)) + geom_bin2d() 16.3.2 Carte thermique d’un Dataframe On peut utiliser une carte thermique pour visualiser le dataframe. Vous pouvez aussi chercher comment You can also look into mettre à l’échelle les colonnes pour visualiser vos données sur une échelle commune. Dans cet example, nous utilisons geom_tile pour représenter toutes les cellules du dataframe et les colorier selon leur valeur: library(pgmm) # data library(tidyverse) # processing/graphing library(viridis) # color palette data(wine) # convert to column, value wine_new &lt;- wine %&gt;% rownames_to_column() %&gt;% gather(colname, value, -rowname) ggplot(wine_new, aes(x = rowname, y = colname, fill = value)) + geom_tile() + scale_fill_viridis() + ggtitle(&quot;Italian Wine Dataframe&quot;) # only difference from above is scaling wine_scaled &lt;- data.frame(scale(wine)) %&gt;% rownames_to_column() %&gt;% gather(colname, value, -rowname) ggplot(wine_scaled, aes(x = rowname, y = colname, fill = value)) + geom_tile() + scale_fill_viridis() + ggtitle(&quot;Italian Wine Dataframe, Scaled&quot;) 16.3.3 Modifications Vous pouvez changer la palette de couleur en l’indiquant explicitement dans vos appels de fonction ggplot. L’épaisseur des comptiments peut aussi être ajoutée via l’appel de fonction geom_bin2d(): library(viridis) # viridis color palette # create plot g1 &lt;- ggplot(SpeedSki, aes(Year, Speed)) + scale_fill_viridis() # modify color # show plot g1 + geom_bin2d(binwidth = c(5, 5)) # modify bin width Voici quelques autres examples: # larger bin width g1 + geom_bin2d(binwidth = c(10, 10)) # hexagonal bins g1 + geom_hex(binwidth = c(5, 5)) # hexagonal bins + scatterplot layer g1 + geom_hex(binwidth = c(5, 5), alpha = .4) + geom_point(size = 2, alpha = 0.8) # hexagonal bins with custom color gradient/bin count ggplot(SpeedSki, aes(Year, Speed)) + scale_fill_gradient(low = &quot;#cccccc&quot;, high = &quot;#09005F&quot;) + # color geom_hex(bins = 10) # number of bins horizontally/vertically 16.4 Theorie Les cartes thermiques sont comme une sorte de combinaiso de nuage de points et histogrammes: ils vous permettent de comparer différents paramètres tout en voyant leurs distributions respectives. Même si les cartes thermiques sont visuellement esthétiques, il y a souvent des meilleures façons de représenter les données. Pour plus d’informations, suivez ce DataCamp sur les cartes thermiques et des alternatives. 16.5 Ressources Externes R Graph Gallery: Heatmaps: Has examples of creating heatmaps with the heatmap() function. Comment faire une carte thermique simple avec ggplot2: Créez une carte thermique avec geom_tile(). "],
["maps.html", "17 Spatial Data 17.1 Les choropleth maps 17.2 Square bins 17.3 Données sur la Longitude / Latitude", " 17 Spatial Data En cours de progression. Toute amélioration est la bienvenue. Si vous souhaitez participer rendez vous sur contribuer au repo. 17.1 Les choropleth maps Les choropleth maps utilisent de la couleur pour indiquer la valeur d’une variable dans une région définie, généralement région politiques. “Mapping in R just got a whole lot easier” par Sharon Machlis (2017-03-03) propose un tutoriel sur l’utilisation des packages tmap, tmaptools, et tigris pour créer des choropleth maps. Notez qu’avec cette approche, vous devrez fusionner des shapefiles géographiques avec vos autres données, avant de mapper. “Step-by-Step Choropleth Map in R: A case of mapping Nepal” parcourt le processus de création d’une choropleth map avec rgdal et ggplot2. (Nous n’avons suivi aucun de ces tutoriels pas à pas…. Si vous le faites, veuillez donner votre avis en soumettant un avis). Le package choroplethr permet de dessiner facilement des choropleth maps des États américains, pays et secteurs de recensement, ainsi que les pays du monde sans traiter directement avec les shapefiles. Son compagnon le package, choroplethrZip, fournit des données pour faire des choropleth sur les zip code; choroplethrAdmin1 dessine des choropleths pour les régions administratives des pays du monde. Ce qui suit est un bref tutoriel sur l’utilisation de ces packages. Remarque: Vous devrez aussi installer choroplethrMaps pour pouvoir travailler avec choroplethr. En outre, choroplethr possède un certain nombre d’autres dépendances qui devraient être installé automatiquement, mais si elles ne l’étaient pas, vous pouvez les installer manuellement le package manquant en appelant library(choroplethr): maptools, et rgdal, sp. Maintenant nous allons utiliser le jeu de données state.x77 pour cet exemple: library(tidyverse) library(choroplethr) # data frame doit contenir &quot;region&quot; et &quot;value&quot; columns df_illiteracy &lt;- state.x77 %&gt;% as.data.frame() %&gt;% rownames_to_column(&quot;state&quot;) %&gt;% transmute(region = tolower(`state`), value = Illiteracy) state_choropleth(df_illiteracy, title = &quot;State Illiteracy Rates, 1977&quot;, legend = &quot;Percent Illiterate&quot;) Remarque: le “cours gratuit” choroplethr sur lequel vous pourriez tomber arrive un cours à la fois, il ne constitue donc pas la meilleure option, à moins que vous ne disposiez de quelques semaines à perdre. 17.2 Square bins Les packages tels que statebins permettent de créer des choropleth maps des régions en maintenant approximativement l’emplacement de la région, mais ni la taille ni la forme. Important: N’installez pas statebins depuis CRAN; utilisez la version en développement – il contient de nombreuses améliorations, détaillées dans “Statebins Reimagined”. # devtools::install_github(&quot;hrbrmstr/statebins&quot;) library(statebins) df_illit &lt;- state.x77 %&gt;% as.data.frame() %&gt;% rownames_to_column(&quot;state&quot;) %&gt;% select(state, Illiteracy) # Remarque: direction = 1 change l&#39;ordre des fill scale # les nuances si foncées représentent des taux d&#39;analphabétisme plus élevés # (The default is -1). statebins(df_illit, value_col=&quot;Illiteracy&quot;, name = &quot;%&quot;, direction = 1) + ggtitle(&quot;State Illiteracy Rates, 1977&quot;) + theme_statebins() 17.3 Données sur la Longitude / Latitude Notez que les options ci-dessus fonctionnent avec les frontières politiques, basé sur les noms des régions que vous fournissez. Ces maps requièrent des packages avec des informations sur les limites géographiques. Les données de longitude / latitude, d’autre part, peuvent être tracées simplement avec un scatterplot où x = longitude et y = latitude, sans aucune maps contextuelle (juste ne pas confondre x &amp; y!). La première partie de “Data wrangling visualisation and spatial analysis: R Workshop” par C. Brown, D. Schoeman, A. Richardson, et B. Venables fournit une procédure détaillée d’exploration et d’analyse de données spatiales avec les données copepod (un type de zooplancton) en utilisant cette technique avec ggplot2::geom_point(). Si on veut ajouter un fond d’écran, il y a plusieurs options. Le tutoriel mentionné ci-dessus fournit des exemples en utilisant les packages maps ou sf. C’est une ressource hautement recommandée, car elle couvre une grande partie du processus de la Data Science, notamment dans le contexte de l’obtention, du nettoyage, de la transformation des données, de l’exploration des données,de la modélisation et de la prédiction. Un autre bon choix pour les maps contextualisées est ggmap, qui offre plein d’options différentes. L’API Google Maps était la solution idéale, mais maintenant elle vous demande de souscrire à la solution payante Google Cloud. A votre inscription, vous obtiendrez un crédit gratuit de 300 USD, mais si vous ne souhaitez pas fournir de carte de crédit lors de l’inscription, vous pouvez utiliser Stamen Maps la fonction get_stamenmap() à la place. Utilisez la version de développement du package; des instructions et de nombreux exemples sont disponibles sur la page GitHub “Getting started Stamen maps with ggmap” et vous aidera à démarrer avec les maps Stamen à travers notamment un exemple utilisant le jeu de données Sacramento dans le package caret. "],
["leaflet.html", "18 Interactive Geographic Data 18.1 Vue d’ensemble 18.2 Brève description du jeu de données 18.3 Plotting Markers 18.4 Heatmaps dynamiques 18.5 Clustering dynamique 18.6 Afficher les groupes 18.7 Afficher des données catégorielles 18.8 External Resources", " 18 Interactive Geographic Data Ce chapitre est à l’origine une contribution communautaire de AkhilPunia En cours de progression. Toute amélioration est la bienvenue. Si vous souhaitez participer rendez vous sur contribuer au repo. 18.1 Vue d’ensemble Vous connaissez certainement différentes libraries pour afficher des données géographiques telles que ggmap etchoroplethr. Bien que ces libraries fournissent de nombreuses fonctionnalités intéressantes pour mieux présenter les informations avec des graphes 2D, ils leur manquent encore une caractéristique importante : l’interactivité. Voici “leaflet” - une librairie écrit en javascript pour gérer les cartes interactives. Fait amusant : il est activement utilisé par de nombreux grands journaux, tels que le New York Times ou le Washington Post. Plongeons nous dedans. 18.2 Brève description du jeu de données Pour notre analyse, nous utiliserons le NYC Open Data décrivant les écoles de New York City en 2016. Vous en trouverez plus sur la page Kaggle. Nous allons nous concentrer sur les distributions de différentes variables en tant que facteur de positions géographiques. library(tidyverse) library(leaflet) library(htmltools) library(leaflet.extras) library(viridis) schools &lt;- read_csv(&#39;data/2016_school_explorer.csv&#39;) 18.3 Plotting Markers Ici, nous pouvons voir que toutes les écoles privées à New York ont été tracées sur une carte que l’on peut zoomer et dézoomer. Les marqueurs sont utilisés pour indiquer l’emplacement de chaque école. Si nous survolons un marqueur, il affiche le nom de l’école. Trop cool, non ?! Voici le code : lat&lt;-median(schools$Latitude) lon&lt;-median(schools$Longitude) schools %&gt;% filter(`Community School?`==&quot;Yes&quot;) %&gt;% leaflet(options = leafletOptions(dragging = TRUE)) %&gt;% addTiles() %&gt;% addMarkers(label=~`School Name`) %&gt;% setView(lng=lon,lat=lat, zoom = 10) 18.4 Heatmaps dynamiques Les Heatmaps sont des outils vraiment utiles pour visualiser la distribution d’une variable particulière sur une région donnée (ils sont si utiles que nous avons une page sur eux). Dans cet exemple, nous voyons comment leaflet est capable de calculer dynamiquement le nombre d’écoles dans une région donnée à partir de données de latitude et de longitude uniquement. Vous pouvez en faire l’expérience en effectuant un zoom avant ou arrière dans le graphique. Voici le code : lat&lt;-mean(schools$Latitude) lon&lt;-mean(schools$Longitude) leaflet(schools) %&gt;% addProviderTiles(providers$CartoDB.DarkMatterNoLabels) %&gt;% addWebGLHeatmap(size=15,units=&quot;px&quot;) %&gt;% setView(lng=lon,lat=lat, zoom = 10) 18.5 Clustering dynamique Nous pouvons voir ici comment leaflet permet de regrouper dynamiquement des données en fonction de leur distance géographique à un niveau de zoom donné. Voici le code : schools %&gt;% leaflet() %&gt;% addTiles() %&gt;% addCircleMarkers(radius = 2, label = ~htmlEscape(`School Name`), clusterOptions = markerClusterOptions()) 18.6 Afficher les groupes Voici le code : top&lt;- schools %&gt;% group_by(District)%&gt;% summarise(top=length(unique(`School Name`)),lon=mean(Longitude),lat=mean(Latitude))%&gt;% arrange(desc(top))%&gt;% head(10) pal &lt;- colorFactor(viridis(100),levels=top$District ) top %&gt;% leaflet(options = leafletOptions(dragging = TRUE)) %&gt;% addProviderTiles(providers$CartoDB.DarkMatterNoLabels) %&gt;% addCircleMarkers(radius=~top/10,label=~paste0(&quot;District &quot;, District,&quot; - &quot;, top,&quot; Schools&quot;),color=~pal(District),opacity = 1) %&gt;% setView(lng=lon,lat=lat, zoom = 10) %&gt;% addLegend(&quot;topright&quot;, pal = pal, values = ~District, title = &quot;District&quot;, opacity = 0.8) 18.7 Afficher des données catégorielles Nous pouvons visualiser la distribution d’une catégorie particulière sur la carte. Ceci est réalisé grâce à un widget interactif situé en haut à droite qui permet de choisir une ou plusieurs catégories particulières. L’exemple ci-dessous montre comment les écoles de diffèrents, certains quartiers sont séparés de manière raciale. Voici le code : ss &lt;- schools %&gt;% dplyr::select(`School Name`,Latitude, Longitude,`Percent White`, `Percent Black`, `Percent Asian`, `Percent Hispanic`) segregation &lt;- function(x){ majority = c() w &lt;- gsub(&quot;%&quot;,&quot;&quot;,x$`Percent White`) b &lt;- gsub(&quot;%&quot;,&quot;&quot;,x$`Percent Black`) a &lt;- gsub(&quot;%&quot;,&quot;&quot;,x$`Percent Asian`) h &lt;- gsub(&quot;%&quot;,&quot;&quot;,x$`Percent Hispanic`) for (i in seq(1,nrow(ss))){ if (max(w[i],b[i],a[i],h[i]) == w[i]) {majority &lt;- c(majority,&#39;White&#39;)} else if (max(w[i],b[i],a[i],h[i]) == b[i]) {majority &lt;- c(majority,&#39;Black&#39;)} else if (max(w[i],b[i],a[i],h[i]) == a[i]) {majority &lt;- c(majority,&#39;Asian&#39;)} else if (max(w[i],b[i],a[i],h[i]) == h[i]) {majority &lt;- c(majority,&#39;Hispanic&#39;)} } return(majority) } ss$race &lt;- segregation(ss) white &lt;- ss %&gt;% filter(race == &quot;White&quot;) black &lt;- ss %&gt;% filter(race == &quot;Black&quot;) hispanic &lt;- ss %&gt;% filter(race == &quot;Hispanic&quot;) asian &lt;- ss %&gt;% filter(race ==&quot;Asian&quot;) lng &lt;- median(ss$Longitude) lat &lt;- median(ss$Latitude) pal_sector &lt;- colorFactor( viridis(4), levels = ss$race) m3 &lt;- leaflet() %&gt;% addProviderTiles(&quot;CartoDB&quot;) %&gt;% addCircleMarkers(data = white, radius = 2, label = ~htmlEscape(`School Name`), color = ~pal_sector(race), group = &quot;White&quot;) m3 %&gt;% addCircleMarkers(data = black, radius = 2, label = ~htmlEscape(`School Name`), color = ~pal_sector(race), group = &quot;Black&quot;) %&gt;% addCircleMarkers(data = hispanic, radius = 2, label = ~htmlEscape(`School Name`), color = ~pal_sector(race), group = &quot;Hispanic&quot;) %&gt;% addCircleMarkers(data = asian, radius = 2, label = ~htmlEscape(`School Name`), color = ~pal_sector(race), group = &quot;Asian&quot;) %&gt;% addLayersControl(overlayGroups = c(&quot;White&quot;, &quot;Black&quot;,&quot;Hispanic&quot;,&quot;Asian&quot;)) %&gt;% setView(lng=lng,lat=lat,zoom=10) Ces exemples ne donnent qu’un aperçu de ce qui est vraiment possible avec cette librairie. Si vous souhaitez explorer davantage de fonctionnalités et de cas d’utilisation, consultez les liens ci-dessous. 18.8 External Resources Leaflet in R Documentation: documentation principale du package. Basic leaflet maps in R: tutoriel avec exemples. Interesting Kaggle Kernel visualizing earthquake data using leaflet in R: un autre cas d’étude à explorer. "],
["network.html", "19 Interactive Networks 19.1 visNetwork (interactive)", " 19 Interactive Networks 19.1 visNetwork (interactive) visNetwork est une puissante implémentation via R de la librairie JavaScript vis.js; il utilise tidyverse: Documentation VisNetwork. –&gt; Le Vignette a des exemples clairement élaborés disponibles sur : https://cran.r-project.org/web/packages/visNetwork/vignettes/Introduction-to-visNetwork.html La documentation visNetwork ne fournit pas le même niveau d’explication que la documentation original, il est donc intéressant de consulter la documentation de vis.js : http://visjs.org/index.html En particulier, les exemples interactifs sont particulièrement utiles pour essayer différentes options. Par exemple, vous pouvez essayer des options concrètes avec le network configurator. 19.1.1 L’exemple service minimum Créer un node data frame avec au moins une colonne (appelée id) contenant le nom des noeuds : # nodes boroughs &lt;- data.frame(id = c(&quot;The Bronx&quot;, &quot;Manhattan&quot;, &quot;Queens&quot;, &quot;Brooklyn&quot;, &quot;Staten Island&quot;)) Créer un autre dataframe contenant les arêtes avec pour colonnes from et to. # edges connections &lt;- data.frame(from = c(&quot;The Bronx&quot;, &quot;The Bronx&quot;, &quot;Queens&quot;, &quot;Queens&quot;, &quot;Manhattan&quot;, &quot;Brooklyn&quot;), to = c(&quot;Manhattan&quot;, &quot;Queens&quot;, &quot;Brooklyn&quot;, &quot;Manhattan&quot;, &quot;Brooklyn&quot;, &quot;Staten Island&quot;)) Dessinons le graphe avec visNetwork(nodes, edges) library(visNetwork) visNetwork(boroughs, connections) Tu peux ajouter des labels en ajoutant l’argument label à la colonne nodes: library(dplyr) boroughs &lt;- boroughs %&gt;% mutate(label = id) visNetwork(boroughs, connections) 19.1.2 Performance visNetwork peut être très lent. %&gt;% visPhysics(stabilization = FALSE) commence l’affichage avant que la stabilisation soit complète, ce qui accélère réellement les choses mais vous permet de voir ce qui se passe en temps réel. Cela fait une grande différence dans l’expérience utilisateur. (C’est aussi amusant de regarder la stabilisation du graphe). D’autres astuces de performance sont décrites ici. 19.1.3 Des outils de configuration utiles %&gt;% visConfigure(enabled = TRUE) est un outil utile pour configurer les options de manière interactive. Une fois terminé, cliquez sur “generate options” pour que le code reproduise les paramètres. Plus d’info ici (Notez que changer les options puis les visualiser nécessite beaucoup le défilement vertical dans le navigateur. Je ne suis pas sûr que quelque chose peut être fait à ce sujet. Si vous avez une solution, n’hésitez pas à partager !) 19.1.4 Colorer les noeuds Ajouter une colonne avec les vrais noms des couleurs dans le dataframe des noeuds : boroughs &lt;- boroughs %&gt;% mutate(is.island = c(FALSE, TRUE, FALSE, FALSE, TRUE)) %&gt;% mutate(color = ifelse(is.island, &quot;blue&quot;, &quot;yellow&quot;)) visNetwork(boroughs, connections) 19.1.5 Noeuds orientés (flèches) visNetwork(boroughs, connections) %&gt;% visEdges(arrows = &quot;to;from&quot;, color = &quot;green&quot;) 19.1.6 Désactiver le mouvement du graphe C’est beaucoup plus rapide sans la simulation. Le nodes sont placés au hasard et peuvent être déplacés sans affecter le reste du graphe, au moins dans le cas des petits graphes. visNetwork(boroughs, connections) %&gt;% visEdges(physics = FALSE) 19.1.7 Griser les noeuds loins de celui selectionné (par définition du degré) (Cliquez sur un noeud pour voir l’effet) # defaults to 1 degree visNetwork(boroughs, connections) %&gt;% visOptions(highlightNearest = TRUE) # set degree to 2 visNetwork(boroughs, connections) %&gt;% visOptions(highlightNearest = list(enabled = TRUE, degree = 2)) "],
["timeseriesbasic.html", "20 Séries temporelles 20.1 Vue d’ensemble 20.2 Séries temporelles simples/multiples 20.3 Tendance générale 20.4 Tendance saisonnière 20.5 Fréquence des données", " 20 Séries temporelles Ce chapitre a été réalisé dans le cadre d’une collaboration communautaire créée par HaiqingXu Cette page est un travail en cours. Nous apprécions tout commentaire ou feedback. Si vous voulez nous aider à améliorer cette page, vous pouvez contribuer à notre repo. 20.1 Vue d’ensemble Cette section présente les graphiques qui peuvent être utilisés pour représenter des séries temporelles. 20.2 Séries temporelles simples/multiples On peut représenter les séries temporelles en utilisant geom_line() avec le temps représenté sur l’axe x. Cet axe doit être un objet de la classe Date, sous l’hypothèse qu’il n’y a pas de données pour les heures/minutes/secondes. library(tidyverse) ggplot(data = economics, aes(x = date, y = pop))+ geom_line(color = &quot;blue&quot;) + ggtitle(&quot;US Population, in Thousands&quot;) + labs(x = &quot;year&quot;, y = &quot;population&quot;) Nous pouvons également représenter plusieurs séries temporelles sur un même graphique pour pouvoir les comparer. df &lt;- read_csv(&quot;data/mortgage.csv&quot;) ## Parsed with column specification: ## cols( ## DATE = col_date(format = &quot;&quot;), ## `5/1 ARM` = col_double(), ## `15 YR FIXED` = col_double(), ## `30 YR FIXED` = col_double() ## ) df &lt;- df %&gt;% gather(key = TYPE, value = RATE, -DATE) %&gt;% mutate(TYPE = forcats::fct_reorder2(TYPE, DATE, RATE)) # puts legend in correct order g &lt;- ggplot(df, aes(DATE, RATE, color = TYPE)) + geom_line() + ggtitle(&quot;U.S. Mortgage Rates&quot;) + labs (x = &quot;&quot;, y = &quot;percent&quot;) + theme_grey(16) + theme(legend.title = element_blank()) g L’exemple suivant représente le prix de clôture pour quatre grandes entreprises tech aux Etats-Unis. Lorsque l’on analyse le GDP, niveau de salaire et prix des actions, il est parfois difficile de comparer des tendances puisque les échelles sont totalement différentes. Par exemple, puisque les prix par action de AAPL et MSFT sont tellement basses comparées au prix par action de GOOG, il est difficile de discerner des tendances dans les données: library(tidyquant) stocks &lt;- c(&quot;AAPL&quot;, &quot;GOOG&quot;, &quot;IBM&quot;, &quot;MSFT&quot;) df &lt;- tq_get(stocks, from = as.Date(&quot;2013-01-01&quot;), to = as.Date(&quot;2013-12-31&quot;)) ggplot(df, aes(date, y = close, color = fct_reorder2(symbol, date, close))) + geom_line() + xlab(&quot;&quot;) + ylab(&quot;&quot;) + theme(legend.title = element_blank()) Dans ce cas-là, il peut être utile de redimensionner les données. On peut faire ceci de façon à ce que chaque prix par action pour chacune de ces entreprises ait un prix de 100 en janvier 2013. df &lt;- df %&gt;% group_by(symbol) %&gt;% mutate(rescaled_close = 100*close / close[1]) ggplot(df, aes(date, y = rescaled_close, color = fct_reorder2(symbol, date, rescaled_close))) + geom_line() + xlab(&quot;&quot;) + ylab(&quot;&quot;) + theme(legend.title = element_blank()) 20.3 Tendance générale Au lieu de regarder les observations dans le temps, on veut souvent connaître la tendance générale à long terme de nos séries temporelles. Dans ce cas-ci, on peut utiliser geom_smooth(). On utilisera le lissage Loess. AAPL &lt;- df %&gt;% filter(symbol == &quot;AAPL&quot;) g &lt;- ggplot(AAPL, aes(date, close)) + geom_point() g + geom_line(color = &quot;grey50&quot;) + geom_smooth(method = &quot;loess&quot;, se = FALSE, lwd = 1.5) + ggtitle(&quot;Loess Smoother for Apple Stock Price&quot;) + labs(x = &quot;Date&quot;, y = &quot;Price&quot;) Une expérience avec différents paramètres de lissage: g + geom_smooth(method = &quot;loess&quot;, span = .5, se = FALSE) 20.4 Tendance saisonnière En plus de la tendance générale, il y a aussi des tendances saisonnières dans les séries temporelles. Une façon de les visualiser est d’utiliser des faits de saison (jour du mois, jour de la semaine, etc.) library(lubridate) dfman &lt;- read_csv(&quot;data/ManchesterByTheSea.csv&quot;) ggplot(dfman, aes(Date, Gross)) + geom_line() + facet_grid(wday(Date, label = TRUE)~.) Ou, on peut créer un graphique qui montre le résultat pour chaque mois. monthplot(AirPassengers) 20.5 Fréquence des données Et si on voulait observer la fréquence des séries temporelles? Facile: utilisez geom_point() en plus de geom_line(). # read file mydat &lt;- read_csv(&quot;data/WA_Sales_Products_2012-14.csv&quot;) %&gt;% mutate(Revenue = Revenue/1000000) # convert Quarter to a single numeric value Q mydat$Q &lt;- as.numeric(substr(mydat$Quarter, 2, 2)) # convert Q to end-of-quarter date mydat$Date &lt;- as.Date(paste0(mydat$Year, &quot;-&quot;, as.character(mydat$Q*3), &quot;-30&quot;)) Methoddata &lt;- mydat %&gt;% group_by(Date, `Order method type`) %&gt;% summarize(Revenue = sum(Revenue)) g &lt;- ggplot(Methoddata, aes(Date, Revenue, color = `Order method type`)) + geom_line(aes(group = `Order method type`)) + scale_x_date(limits = c(as.Date(&quot;2012-02-01&quot;), as.Date(&quot;2014-12-31&quot;)), date_breaks = &quot;6 months&quot;, date_labels = &quot;%b %Y&quot;) + ylab(&quot;Revenue in mil $&quot;) g + geom_point() C’est possible qu’il y ait des valeurs manquantes dans les séries temporelles. Utiliser geom_point() avec geom_line() est une façon de les détecter. Ici nous introduisons une méthode alternative: laisser des gaps. Methoddata$Date[year(Methoddata$Date)==2013] &lt;- NA g &lt;- ggplot(Methoddata, aes(Date, Revenue, color = `Order method type`)) + geom_path(aes(group = `Order method type`)) + scale_x_date(limits = c(as.Date(&quot;2012-02-01&quot;), as.Date(&quot;2014-12-31&quot;)), date_breaks = &quot;6 months&quot;, date_labels = &quot;%b %Y&quot;) + ylab(&quot;Revenue in mil $&quot;) g "],
["tidyquant.html", "21 Stock data with tidyquant 21.1 Vue d’ensemble 21.2 Qu’est ce que tidyquant ? 21.3 Installer tidyquant 21.4 Simple timeseries 21.5 Timeseries multiples 21.6 Ressources externes", " 21 Stock data with tidyquant Ce chapitre est à l’origine une contribution communautaire de naotominakawa En cours de progression. Toute amélioration est la bienvenue. Si vous souhaitez participer rendez vous sur contribuer au repo. 21.1 Vue d’ensemble Cette section explique comment utiliser le package tidyquant pour effectuer une analyse de timeseries. 21.2 Qu’est ce que tidyquant ? tidyquant est une solution complète dédiée à l’analyse financière. Il intervient dans l’analyse des données temporelles (timeseries), telles que des données financières ou économiques. tidyquant se connecte à diverses sources de données telles que Yahoo! Finance, Morning Star, données de marché Bloomberg, etc. Il se comporte également bien avec les autres packages tels que Tidyverse. 21.3 Installer tidyquant Vous pouvez installer tidyquant à partir de CRAN: install.packages(&quot;tidyquant&quot;) Si vous voulez voir quelles functions sont disponibles, vous pouvez exécuter les commandes suivantes : # to see which functions are available (not run) library(tidyquant) tq_transmute_fun_options() 21.4 Simple timeseries Obtenir des données historiques pour un stock unique (par exemple, Google) : # get historical data for single stock. e.g. google library(tidyquant) tq_get(&quot;GOOGL&quot;, get=&quot;stock.prices&quot;) ## # A tibble: 2,726 x 7 ## date open high low close volume adjusted ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2009-01-02 154. 161. 153. 161. 7213700 161. ## 2 2009-01-05 161. 166. 158. 164. 9768200 164. ## 3 2009-01-06 167. 171. 163. 167. 12837500 167. ## 4 2009-01-07 164. 166. 160. 161. 8980000 161. ## 5 2009-01-08 159. 163. 159. 163. 7194100 163. ## 6 2009-01-09 164. 164. 157. 158. 8672300 158. ## 7 2009-01-12 158. 160. 155. 157. 6601900 157. ## 8 2009-01-13 156. 160. 155. 157. 8856100 157. ## 9 2009-01-14 155. 157. 149. 151. 10924800 151. ## 10 2009-01-15 149. 152. 144. 150. 11857100 150. ## # … with 2,716 more rows Calculer le retour mensuel de stock unique : library(dplyr) # calculate monthly return of single stock tq_get(c(&quot;GOOGL&quot;), get=&quot;stock.prices&quot;) %&gt;% tq_transmute(select=adjusted, mutate_fun=periodReturn, period=&quot;monthly&quot;, col_rename = &quot;monthly_return&quot;) ## # A tibble: 130 x 2 ## date monthly_return ## &lt;date&gt; &lt;dbl&gt; ## 1 2009-01-30 0.0536 ## 2 2009-02-27 -0.00160 ## 3 2009-03-31 0.0298 ## 4 2009-04-30 0.138 ## 5 2009-05-29 0.0537 ## 6 2009-06-30 0.0104 ## 7 2009-07-31 0.0509 ## 8 2009-08-31 0.0420 ## 9 2009-09-30 0.0740 ## 10 2009-10-30 0.0812 ## # … with 120 more rows Créer un line chart du prix de clôture pour un stock donné : # showing closing price for single stock library(ggplot2) tq_get(c(&quot;GOOGL&quot;), get=&quot;stock.prices&quot;) %&gt;% ggplot(aes(date, close)) + geom_line() Créer un line chart du retour mensuel pour un stock donné : # showing monthly return for single stock tq_get(c(&quot;GOOGL&quot;), get=&quot;stock.prices&quot;) %&gt;% tq_transmute(select=adjusted, mutate_fun=periodReturn, period=&quot;monthly&quot;, col_rename = &quot;monthly_return&quot;) %&gt;% ggplot(aes(date, monthly_return)) + geom_line() 21.5 Timeseries multiples Obtenir des données historiques pour plusieurs actions (par exemple, GAFA) : # get historical data for multiple stocks. e.g. GAFA tq_get(c(&quot;GOOGL&quot;,&quot;AMZN&quot;,&quot;FB&quot;,&quot;AAPL&quot;), get=&quot;stock.prices&quot;) ## # A tibble: 10,053 x 8 ## symbol date open high low close volume adjusted ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 GOOGL 2009-01-02 154. 161. 153. 161. 7213700 161. ## 2 GOOGL 2009-01-05 161. 166. 158. 164. 9768200 164. ## 3 GOOGL 2009-01-06 167. 171. 163. 167. 12837500 167. ## 4 GOOGL 2009-01-07 164. 166. 160. 161. 8980000 161. ## 5 GOOGL 2009-01-08 159. 163. 159. 163. 7194100 163. ## 6 GOOGL 2009-01-09 164. 164. 157. 158. 8672300 158. ## 7 GOOGL 2009-01-12 158. 160. 155. 157. 6601900 157. ## 8 GOOGL 2009-01-13 156. 160. 155. 157. 8856100 157. ## 9 GOOGL 2009-01-14 155. 157. 149. 151. 10924800 151. ## 10 GOOGL 2009-01-15 149. 152. 144. 150. 11857100 150. ## # … with 10,043 more rows Créez un multiple line chart des cours de clôture de plusieurs actions (GAFA à nouveau). Nous pouvons afficher chaque action dans une couleur différente sur le même graphique : # Create a multiple line chart of the closing prices of the four stocks, # showing each stock in a different color on the same graph. tq_get(c(&quot;GOOGL&quot;,&quot;AMZN&quot;,&quot;FB&quot;,&quot;AAPL&quot;), get=&quot;stock.prices&quot;) %&gt;% ggplot(aes(date, close, color=symbol)) + geom_line() Transformer les données pour que chaque stock commence à 100 et réafficher (il s’agit de standardiser les données pour pouvoir comparer les timeseries) : # Create a multiple line chart of the closing prices of the four stocks, # showing each stock in a different color on the same graph. # Transform the data so each stock begins at 100 and replot. tq_get(c(&quot;GOOGL&quot;,&quot;AMZN&quot;,&quot;FB&quot;,&quot;AAPL&quot;), get=&quot;stock.prices&quot;) %&gt;% group_by(symbol) %&gt;% mutate(close = 100*close/first(close)) %&gt;% ggplot(aes(date, close, color=symbol)) + geom_line() Calculez le retour mensuel de plusieurs actions (encore une fois, GAFA): # calculate monthly return of multiple stocks tq_get(c(&quot;GOOGL&quot;,&quot;AMZN&quot;,&quot;FB&quot;,&quot;AAPL&quot;), get=&quot;stock.prices&quot;) %&gt;% group_by(symbol) %&gt;% tq_transmute(select=adjusted, mutate_fun=periodReturn, period=&quot;monthly&quot;, col_rename = &quot;monthly_return&quot;) ## # A tibble: 480 x 3 ## # Groups: symbol [4] ## symbol date monthly_return ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 GOOGL 2009-01-30 0.0536 ## 2 GOOGL 2009-02-27 -0.00160 ## 3 GOOGL 2009-03-31 0.0298 ## 4 GOOGL 2009-04-30 0.138 ## 5 GOOGL 2009-05-29 0.0537 ## 6 GOOGL 2009-06-30 0.0104 ## 7 GOOGL 2009-07-31 0.0509 ## 8 GOOGL 2009-08-31 0.0420 ## 9 GOOGL 2009-09-30 0.0740 ## 10 GOOGL 2009-10-30 0.0812 ## # … with 470 more rows Créez un multiple line chart donnant le rendement mensuel des quatre actions. De nouveau, nous pouvons afficher chaque action dans une couleur différente sur le même graphique: # Create a multiple line chart of monthly return of the four stocks, # showing each stock in a different color on the same graph tq_get(c(&quot;GOOGL&quot;,&quot;AMZN&quot;,&quot;FB&quot;,&quot;AAPL&quot;), get=&quot;stock.prices&quot;) %&gt;% group_by(symbol) %&gt;% tq_transmute(select=adjusted, mutate_fun=periodReturn, period=&quot;monthly&quot;, col_rename = &quot;monthly_return&quot;) %&gt;% ggplot(aes(date, monthly_return, color=symbol)) + geom_line() 21.6 Ressources externes tidyquant CRAN doc: documentation formelle du package tidyquant Github repo: Le repo Github de tidyquant avec un bon README "],
["import.html", "22 Importer des données 22.1 Vue d’ensemble 22.2 Importer des datasets déjà implémentés dans R 22.3 Importer des données stockées localement 22.4 Importer des données web 22.5 Importer des données à partir de bases de données 22.6 Plus de ressources", " 22 Importer des données Ce chapitre a été réalisé dans le cadre d’une collaboration communautaire créée par ZhangZhida Cette page est un travail en cours. Nous apprécions tout commentaire ou feedback. Si vous souhaitez améliorer cette page, vous pouvez contribuer à notre repo. 22.1 Vue d’ensemble Cette section explique comment importer des données à partir de sources déjà implémentées dans R, de fichiers locaux, sites internet et bases de données. 22.2 Importer des datasets déjà implémentés dans R R contient beaucoup de datasets avec lesquels les utilisateurs peuvent jouer. Vous êtes probablement déjà familier avec plusieurs de ces datasets comme iris, mtcars, beavers, dataset, etc. Comme ces datasets sont déjà “préloadé”, on peut les manipuler directement. Pour une liste complète des datasets déjà présents dans R, se référer aux packages Datasets de R On peut aussi taper data() dans la console pour voir toute la liste. L’option la plus pratique pour visualiser ces datasets est de taper ??datasets: la liste des datasets apparaît alors dans la fenêtre Help à l’écran. Cliquer sur un dataset fera apparaître sa proche page help. Vous y trouverez beaucoup d’informations sur les sources de ces données et la signification de chaque variable. La plupart des datasets sont dit “lazy-loaded”, ce qui signifie que même s’ils n’apparaissent pas dans l’environnement global, il suffit d’y faire référence pour les loader et les utiliser. Cependant, pour certains packages, il faut utiliser data() pour accéder aux datasets, comme ci-dessous: library(pgmm) data(wine) Ceci est une source commune de frustration pour beaucoup d’étudiants: “J’ai installé la librairie et loadé le package mais le dataset n’est pas là!”. Un homme averti en vaut deux: les packages qui tombent dans cette catégories comprennent: lawstat, pgmm, et d’autres encore. (Envoyez-nous une PR pour allonger cette liste) 22.3 Importer des données stockées localement Cette section couvre les fonctions de base de R pour importer des données. Pour les versions tidyverse (read_csv, read_delim, read_table, etc.), voir le chapitre Data Import de *R for Data Science. 22.3.1 Importer des fichiers textes La fonction read.table() est la fonction la plus générale pour lire des fichiers textes. Pour l’utiliser, on doit spécifier comment lire le fichier, c’est-à-dire que nous devons spécifier des paramètres basiques comme sep, header, etc. sep représente le séparateur (virgule, point virgule, etc.) et header est en général TRUE si on veut lire la premier ligne comme en-tête. D’autres paramètres sont aussi utiles à d’autres occasions. Par exemple, na.strings indique que les charactères doivent être interprétés comme des valeurs NAs. df &lt;- read.table(&quot;data/MusicIcecream.csv&quot;, sep=&quot;,&quot;, header=TRUE) head(df) ## Age Favorite Music Freq ## 1 old bubble gum classical 1 ## 2 old bubble gum rock 1 ## 3 old coffee classical 3 ## 4 old coffee rock 1 ## 5 young bubble gum classical 2 ## 6 young bubble gum rock 5 22.3.2 Importer des fichiers CSV CSV est l’abréviation de ‘Comma-Separated Values file’ qui est, comme son nom l’indique, un fichier texte qui emploie des virgules pour séparer chacune de ses données. On peut facilement lire un fichier CSV avec les fonctions intégrées dans R. La fonction read.csv() fournit deux paramètres utiles: header qui peut être mis sur FALSE s’il n’y a pas d’en-tête et sep qui spécifie le séparateur. Par exemple, on peut préciser que le séparateur est sep=&quot;\\t si le fichier CSV utilise en réalité le charactère ‘tab’ pour séparer ses données. Les valeurs par défaut pour header et sep sont TRUE et &quot;,&quot;. read.csv2() est une autre fonction pour lire des fichiers CSV. La différence entre read.csv() et read.csv2 est que le premier utilise tab &quot;\\t&quot; comme séparateur, alors que l’autre utiliser un point virgule &quot;;&quot;. Cela sert de raccourci efficace pour des fichiers CSV de formats différents, souvent selon les régions. Voici un exemple de code pour lire un fichier CSV standard: df &lt;- read.csv(&quot;data/MusicIcecream.csv&quot;) head(df) ## Age Favorite Music Freq ## 1 old bubble gum classical 1 ## 2 old bubble gum rock 1 ## 3 old coffee classical 3 ## 4 old coffee rock 1 ## 5 young bubble gum classical 2 ## 6 young bubble gum rock 5 Une petite remarque concernant la lecture de plusieurs fichiers: R doit connaître notre directory actuel, ce qui peut se faire en utilisant la fonction setwd(). Ensuite, on peut lire tous les fichiers qui se trouvent dans ce directory en entrant le nom de fichier directement, sans avoir à spécifier la location. 22.3.3 Importer un fichier JSON Un fichier JSON est un fichier qui storent des données de structure simple et des objets JavaScript, d’où son nom ‘JavaScript Object Notation (JSON)’. Par exemple, {&quot;name&quot;:&quot;Vince&quot;, &quot;age&quot;:23, &quot;city&quot;:&quot;New York&quot;} est un objet de format JSON. Récemment, JSON est devenu le format standard pour tranférer des données sur des sites internets. Pour lire un fichier JSON, on peut utiliser le package jsonlite. Ce dernier est un JSON parser/generateur optimisé pour internet. Sa force principale est qu’il implémente un mapping bidirectionnel entre les données JSON et les types les plus importants dans R. Dans l’exemple ci-dessous, l’argument simplifyDataFrame = TRUE va directement transformer une liste d’objets JSON en un dataframe. Si vous voulez en savoir plus sur les arguments simplifyVector et simplifyMatrix, qui donnent un contrôle sur d’autres formats de données dans R, veuillez vous référer au document “Getting started with JSON and jsonlite”. library(jsonlite) # read JSON data raw_json_data &lt;- fromJSON(txt = &quot;data/WaterConsumptionInNYC.json&quot;, simplifyDataFrame = TRUE) # transform JSON to Data Frame df &lt;- as.data.frame(raw_json_data) head(df) ## new_york_city_population nyc_consumption_million_gallons_per_day ## 1 7102100 1512 ## 2 7071639 1506 ## 3 7089241 1309 ## 4 7109105 1382 ## 5 7181224 1424 ## 6 7234514 1465 ## per_capita_gallons_per_person_per_day year ## 1 213 1979 ## 2 213 1980 ## 3 185 1981 ## 4 194 1982 ## 5 198 1983 ## 6 203 1984 22.4 Importer des données web 22.4.1 Lire un fichier directement dans notre environnement de travail Prenons l’exemple de Water Consumption In The New York City, qui est sur le site open-source de NYC. Nous pouvons importer les données depuis un URL de la même façon que nous importons des fichiers locaux. library(tidyverse) # specify the URL link to the data source url &lt;- &quot;https://data.cityofnewyork.us/api/views/ia2d-e54m/rows.csv&quot; # read the URL df &lt;- read_csv(url) head(df) ## # A tibble: 6 x 4 ## Year `New York City Pop… `NYC Consumption(Millio… `Per Capita(Gallons p… ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1979 7102100 1512 213 ## 2 1980 7071639 1506 213 ## 3 1981 7089241 1309 185 ## 4 1982 7109105 1382 194 ## 5 1983 7181224 1424 198 ## 6 1984 7234514 1465 203 22.4.2 Scraper une table HTML en utilisant rvest Parfois, on souhaite importer des données qui apparaissent dans une table HTML sur un site internet. Cela peut être un peu désordonné, et le mieux est de d’abord vérifier s’il n’y a pas d’autres moyens pour importer les données avant d’utiliser cette option. S’il n’y a pas d’alternative, rvest rend le procédé le plus facile possible. Voici un exemple simple. Supponsons que nous souhaitons travailler sur les données de quartiers trouvés sur la page Wikipédia Boroughs of New York City page. D’abord, nous lisons la page, trouvons les tables et les récupérons avec html_table: library(tidyverse) library(rvest) nyctables &lt;- read_html(&quot;https://en.wikipedia.org/wiki/Boroughs_of_New_York_City&quot;) %&gt;% html_nodes(&quot;table&quot;) %&gt;% html_table(fill = TRUE) nyctables est une liste de trois éléments, un pour chaque table de la page. Ensuite, nous pouvons vérifier chaque élément jusqu’à ce que nous trouvons ce que nous voulons en consultant la page web originale pour avoir une idée de la location de notre table. (Il y a d’autres méthodes pour identifier ce dont on a besoin sur une page internet dans des situations plus complexes. Voir le paragraphe Ressources additionnelles ci-dessous pour plus d’informations). Il se trouve que la table que nous voulons est le premier élément de la list: mytable &lt;- nyctables[[1]] head(mytable, 3) ## New York City&#39;s five boroughsvte New York City&#39;s five boroughsvte ## 1 Jurisdiction Jurisdiction ## 2 Borough County ## 3 The Bronx Bronx ## New York City&#39;s five boroughsvte New York City&#39;s five boroughsvte ## 1 Population Gross Domestic Product ## 2 Estimate (2017)[3] billions(US$)[4] ## 3 1,471,160 28.787 ## New York City&#39;s five boroughsvte New York City&#39;s five boroughsvte ## 1 Gross Domestic Product Land area ## 2 per capita(US$) square miles ## 3 19,570 42.10 ## New York City&#39;s five boroughsvte New York City&#39;s five boroughsvte ## 1 Land area Density ## 2 squarekm persons / sq. mi ## 3 109.04 34,653 ## New York City&#39;s five boroughsvte ## 1 Density ## 2 persons /sq. km ## 3 13,231 Nous pouvons voir que le nom des colonnes est le même pour toutes les colonnes à cause de l’en-tête fusionnée à partir de l’original. Nous pouvons arranger ceci ainsi que retirer les rangs dont on n’a pas besoin: colnames(mytable) &lt;- c(&quot;borough&quot;, &quot;county&quot;, &quot;population&quot;, &quot;gdp_total&quot;, &quot;gdp_per_capita&quot;, &quot;land_sq_miles&quot;, &quot;land_sq_km&quot;, &quot;density_sq_miles&quot;, &quot;density_sq_km&quot;) # remove unneeded rows mytable &lt;- mytable %&gt;% slice(-c(1, 2, 10)) # convert character to numeric data where appropriate mytable &lt;- mytable %&gt;% mutate_at(vars(population:density_sq_km), parse_number) Maintenant nous sommes prêts à dessiner un graphiques! options(scipen = 999) # turn off scientific notation mytable %&gt;% slice(1:5) %&gt;% select(borough, gdp_per_capita, land_sq_miles, population) %&gt;% gather(var, value, -borough) %&gt;% ggplot(aes(value, fct_reorder2(borough, var==&quot;gdp_per_capita&quot;, value, .desc = FALSE), color = borough)) + geom_point() + ylab(&quot;&quot;) + facet_wrap(~var, ncol = 1, scales = &quot;free_x&quot;) + guides(color = FALSE) Ressources additionnelles Le webinar de RStudio sur l’utilisation de rvest – explique comment utiliser la structure de HTML et CSS sur la page pour scraper l’information qui s’y trouve et dont on a besoin. Il explique aussi comment utiliser certaines fonctions additionnelles de rvest comme html_text(), html_name(), html_attrs(), html_children(), etc. 22.5 Importer des données à partir de bases de données R procure des packages pour manipuler des données de bases de données relationelles comme PostgreSQL, MySQL, etc. Un de ces packages est odbc package, qui est une des interfaces de databases qui permet la communication entre R et les systèmes de gestion de bases de données relationnelles. Plus de ressources sur ce package ici: odbc. Avant de se connecter à une base de données locale, nous devons satisfaire les prérequis du driver ODBC, à travers lequel le package R peut communiquer avec la base de donnée. Pour obtenir de l’aide sur comment installer le driver ODBC sur des systèmes comme Windows, Linus, MacOS, veuillez utiliser ce document:Installer ODBC Driver. Après avoir installé le driver ODBC avec les packages odbc et DBI, nous sommes capables de manipuler la base de données. Pour lire une table de celle-ci, nous passons par les étapes suivantes. Nous créons d’abord une connection vers la base de données grâce à la fonction dbConnect(). Ensuite, nous pouvons faire un peu d’exploration et lister par exemple toutes les tables de la base de données. Pour lancer des queries sur les informations qui nous intéressent, on peut lancer une query SQL dans la base de donnée. Ensuite on peut retrouver les données désirées et dfFetch() nous permet de choisir le nombre de valeurs que nous souhaitons récupérer à la fois. Enfin, lorsque nous avons fini de lire ces données, nous pouvons fermer la connection. library(odbc) library(DBI) # build connection with database con &lt;- dbConnect(odbc::odbc(), driver = &quot;PostgreSQL Driver&quot;, database = &quot;test_db&quot;, uid = &quot;postgres&quot;, pwd = &quot;password&quot;, host = &quot;localhost&quot;, port = 5432) # list all tables in the test_db database dbListTables(con) # read table test_table into Data Frame data &lt;- dbReadTable(con, &quot;test_table&quot;) # write an R Data Frame object to an SQL table # here we write the built-in data mtcars to a new_table in DB data &lt;- dbWriteTable(con, &quot;new_table&quot;, mtcars) # SQL query result &lt;- dbSendQuery(con, &quot;SELECT * FROM test_table&quot;) # Retrieve the first 10 results first_10 &lt;- dbFetch(result, n = 10) # Retrieve the rest of the results rest &lt;- dbFetch(result) # close the connection dbDisconnect(con) 22.6 Plus de ressources Importer des fichiers locaux: This R Data Import Tutorial Is Everything You Need Importer des fichiers JSON: Getting started with JSON and jsonlite Importer des données web: The RCurl Package Importer des fichiers de base de données Databases using R Documentation sur le package odbc odbc Installer le driver ODBC sur son système: Install ODBC Driver "],
["tidy.html", "23 Revue détaillée : Tidy Data &amp; dplyr 23.1 Vue d’ensemble 23.2 Installer les packages 23.3 Voir les données 23.4 Qu’est ce qu’une Tidy data? 23.5 Tibbles 23.6 Test pour les valeurs manquantes 23.7 Remplacer les valeurs manquantes 23.8 Vocabulaire de la manipulation de données 23.9 Renommage 23.10 Select 23.11 Mutate 23.12 Filter 23.13 Arrange 23.14 Summarize &amp; Group By 23.15 Pipe Operator 23.16 Nettoyer les données transformées 23.17 Liens utiles", " 23 Revue détaillée : Tidy Data &amp; dplyr Ce chapitre est à l’origine une contribution communautaire de akshatapatel En cours de progression. Toute amélioration est la bienvenue. Si vous souhaitez participer rendez vous sur contribuer au repo. 23.1 Vue d’ensemble Cet exemple présente certains travaux avec le jeu de données biopsy en utilisant les fonctions de dplyr pour obtenir un tidy dataset. 23.1.1 Les packages dplyr MASS tidyr 23.2 Installer les packages Écrivez le statements suivant dans le console: install.packages('dplyr') install.packages('ggplot2') install.packages('tidyr') install.packages('MASS') Remarque: Les trois premiers packages font partie de tidyverse, une collection de packages utiles dans R, qui peuvent tous être installés à l’aide de install.packages('tidyverse'). dplyr est utilisé pour le formattage et la transformation des données dans un dataframe. Le “d” dans “dplyr” signifie “dataframes” qui est la structure de données la plus utilisée pour stocker des jeux de données dans R. 23.3 Voir les données Commençons par charger le package afin que nous puissions obtenir les données dans des dataframes : #loading the dplyr library library(dplyr) #loading data from MASS:biopsy library(MASS) class(biopsy) ## [1] &quot;data.frame&quot; #glimpse is a part of the dplyr package glimpse(biopsy) ## Observations: 699 ## Variables: 11 ## $ ID &lt;chr&gt; &quot;1000025&quot;, &quot;1002945&quot;, &quot;1015425&quot;, &quot;1016277&quot;, &quot;1017023&quot;, &quot;10… ## $ V1 &lt;int&gt; 5, 5, 3, 6, 4, 8, 1, 2, 2, 4, 1, 2, 5, 1, 8, 7, 4, 4, 10, … ## $ V2 &lt;int&gt; 1, 4, 1, 8, 1, 10, 1, 1, 1, 2, 1, 1, 3, 1, 7, 4, 1, 1, 7, … ## $ V3 &lt;int&gt; 1, 4, 1, 8, 1, 10, 1, 2, 1, 1, 1, 1, 3, 1, 5, 6, 1, 1, 7, … ## $ V4 &lt;int&gt; 1, 5, 1, 1, 3, 8, 1, 1, 1, 1, 1, 1, 3, 1, 10, 4, 1, 1, 6, … ## $ V5 &lt;int&gt; 2, 7, 2, 3, 2, 7, 2, 2, 2, 2, 1, 2, 2, 2, 7, 6, 2, 2, 4, 2… ## $ V6 &lt;int&gt; 1, 10, 2, 4, 1, 10, 10, 1, 1, 1, 1, 1, 3, 3, 9, 1, 1, 1, 1… ## $ V7 &lt;int&gt; 3, 3, 3, 3, 3, 9, 3, 3, 1, 2, 3, 2, 4, 3, 5, 4, 2, 3, 4, 3… ## $ V8 &lt;int&gt; 1, 2, 1, 7, 1, 7, 1, 1, 1, 1, 1, 1, 4, 1, 5, 3, 1, 1, 1, 1… ## $ V9 &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 4, 1, 1, 1, 2, 1… ## $ class &lt;fct&gt; benign, benign, benign, benign, benign, malignant, benign,… head(biopsy) ## ID V1 V2 V3 V4 V5 V6 V7 V8 V9 class ## 1 1000025 5 1 1 1 2 1 3 1 1 benign ## 2 1002945 5 4 4 5 7 10 3 2 1 benign ## 3 1015425 3 1 1 1 2 2 3 1 1 benign ## 4 1016277 6 8 8 1 3 4 3 7 1 benign ## 5 1017023 4 1 1 3 2 1 3 1 1 benign ## 6 1017122 8 10 10 8 7 10 9 7 1 malignant 23.4 Qu’est ce qu’une Tidy data? Qu’est-ce que cela signifie pour vos données d’être tidy ? Tidy data est un format normalisé et constitue une manière cohérente d’organiser vos données dans R. Voici la définition d’une Tidy Data donnée par Hadley Wickham : Un ensemble de données est ordonné our desordonné selon la manière dont les lignes, les colonnes et les tableaux correspondent aux observations, aux variables et aux types. Une tidy data : Chaque variable forme une colonne. Chaque observation forme une ligne. Chaque unité d’observation est une valeur dans la table. Voir r4ds on tidy data pour plus d’info. Quels sont les avantages des tidy data? Uniformité : il est plus facile d’apprendre les outils pour travailler avec ces données car elles sont stockées de façon cohérentes. La plupart des fonctions de base en R utilisent des vecteurs de valeurs. Ainsi, avoir des variables en tant que colonnes/vecteurs permet à la nature vectorielle de R de briller. Pouvez-vous observer et dire pourquoi ces données sont en désordre ? Les noms de colonnes tels que V1, V2 ne sont pas intuitifs dans leur contexte; c’est bon signe que la donnée est untidy. Ce ne sont pas des variables différentes, mais des valeurs d’une variable commune. Nous allons maintenant voir comment transformer nos données en utilisant les fonctions de dplyr et ensuite voir comment comment rendre plus propre ces données. 23.5 Tibbles Un tibble est une structure moderne du dataframe. Ceci est particulièrement utile pour les grands ensembles de données car il n’imprime que les premières lignes. Cela vous aide à faire face plus tôt aux problèmes, ce qui vous permet de nettoyer le code. # Converting a df to a tibble biopsy &lt;- tbl_df(biopsy) biopsy ## # A tibble: 699 x 11 ## ID V1 V2 V3 V4 V5 V6 V7 V8 V9 class ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 1000025 5 1 1 1 2 1 3 1 1 benign ## 2 1002945 5 4 4 5 7 10 3 2 1 benign ## 3 1015425 3 1 1 1 2 2 3 1 1 benign ## 4 1016277 6 8 8 1 3 4 3 7 1 benign ## 5 1017023 4 1 1 3 2 1 3 1 1 benign ## 6 1017122 8 10 10 8 7 10 9 7 1 malignant ## 7 1018099 1 1 1 1 2 10 3 1 1 benign ## 8 1018561 2 1 2 1 2 1 3 1 1 benign ## 9 1033078 2 1 1 1 2 1 1 1 5 benign ## 10 1033078 4 2 1 1 2 1 2 1 1 benign ## # … with 689 more rows 23.6 Test pour les valeurs manquantes # Number of missing values in each column in the data frame colSums(is.na(biopsy)) ## ID V1 V2 V3 V4 V5 V6 V7 V8 V9 class ## 0 0 0 0 0 0 16 0 0 0 0 Le jeu de données contient des valeurs manquantes qui doivent être traitées. 23.7 Remplacer les valeurs manquantes Une façon de traiter les valeurs manquantes consiste à les recoder avec la moyenne de toutes les autres valeurs de cette colonne : #change all the NAs to mean of the column biopsy$V6[is.na(biopsy$V6)] &lt;- mean(biopsy$V6, na.rm = TRUE) colSums(is.na(biopsy)) ## ID V1 V2 V3 V4 V5 V6 V7 V8 V9 class ## 0 0 0 0 0 0 0 0 0 0 0 Consultez notre chapitre sur time series avec données manquantes pour plus d’informations sur la gestion des données manquantes. 23.8 Vocabulaire de la manipulation de données Voici le vocabulaire et les functions les plus couramment utilisés qui aident à manipuler les données et les résumer : Rename Select Mutate Filter Arrange Summarize Group_by Les fonctions Select et mutate manipulent les variables (les colonnes du dataframe). Filter et arrange manipulent les observations (les lignes), enfin summarize manipule les groupes d’observations. Toutes les fonctions de dplyr travaillent sur une copie des données et renvoient une copie modifiée. Ils ne changent pas le dataframe original. Si nous voulons accéder aux résultats par la suite, nous devons enregistrer la copie modifiée. 23.9 Renommage Les noms des colonnes dans nos données biopsy sont très vagues et ne nous donnent pas signification. Nous devons modifier les noms de la colonne afin qu’une personne extérieur puisse avoir une idée des valeurs auxquelles il fait référence. rename(biopsy, thickness = V1,cell_size = V2, cell_shape = V3, marg_adhesion = V4, epithelial_cell_size = V5, bare_nuclei = V6, chromatin = V7, norm_nucleoli = V8, mitoses = V9) ## # A tibble: 699 x 11 ## ID thickness cell_size cell_shape marg_adhesion epithelial_cell… ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1000… 5 1 1 1 2 ## 2 1002… 5 4 4 5 7 ## 3 1015… 3 1 1 1 2 ## 4 1016… 6 8 8 1 3 ## 5 1017… 4 1 1 3 2 ## 6 1017… 8 10 10 8 7 ## 7 1018… 1 1 1 1 2 ## 8 1018… 2 1 2 1 2 ## 9 1033… 2 1 1 1 2 ## 10 1033… 4 2 1 1 2 ## # … with 689 more rows, and 5 more variables: bare_nuclei &lt;dbl&gt;, ## # chromatin &lt;int&gt;, norm_nucleoli &lt;int&gt;, mitoses &lt;int&gt;, class &lt;fct&gt; Le tibble présenté ci-dessus n’est pas enregistré et ne peut plus être utilisé. Pour l’utiliser ensuite, nous l’enregistrons comme un nouveau tibble : #saving the rename function output biopsy_new&lt;-rename(biopsy, thickness = V1,cell_size = V2, cell_shape = V3, marg_adhesion = V4, epithelial_cell_size = V5, bare_nuclei = V6, chromatin = V7, norm_nucleoli = V8, mitoses = V9) head(biopsy_new,5) ## # A tibble: 5 x 11 ## ID thickness cell_size cell_shape marg_adhesion epithelial_cell… ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1000… 5 1 1 1 2 ## 2 1002… 5 4 4 5 7 ## 3 1015… 3 1 1 1 2 ## 4 1016… 6 8 8 1 3 ## 5 1017… 4 1 1 3 2 ## # … with 5 more variables: bare_nuclei &lt;dbl&gt;, chromatin &lt;int&gt;, ## # norm_nucleoli &lt;int&gt;, mitoses &lt;int&gt;, class &lt;fct&gt; Le dataframe biopsy_new peut maintenant être utilisé pour d’autres manipulations. 23.10 Select Select renvoie un sous-ensemble des données. Plus précisément, seules les colonnes spécifiées sont incluses. Dans les données biopsy, nous n’avons pas besoin des variables “chromatin” et “mitoses”. Alors, éliminons-les en utilisant un signe moins: #selecting all except the columns chromatin and mitoses biopsy_new&lt;-select(biopsy_new,-chromatin,-mitoses) head(biopsy_new,5) ## # A tibble: 5 x 9 ## ID thickness cell_size cell_shape marg_adhesion epithelial_cell… ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1000… 5 1 1 1 2 ## 2 1002… 5 4 4 5 7 ## 3 1015… 3 1 1 1 2 ## 4 1016… 6 8 8 1 3 ## 5 1017… 4 1 1 3 2 ## # … with 3 more variables: bare_nuclei &lt;dbl&gt;, norm_nucleoli &lt;int&gt;, ## # class &lt;fct&gt; 23.11 Mutate La fonction mutate crée de nouvelles variables à partir des variables déjà existantes et les ajoute à l’ensemble de données. Il indique que les données déjà contenues mais n’ont jamais été affichées. La variable “V6” contient les valeurs du bare nucleus de 1,00 à 10,00. Si nous voulons normaliser la variable, nous pouvons utiliser la fonction mutate : #normalize the bare nuclei values maximum_bare_nuclei&lt;-max(biopsy_new$bare_nuclei,na.rm=TRUE) biopsy_new&lt;-mutate(biopsy_new,bare_nuclei=bare_nuclei/maximum_bare_nuclei) head(biopsy_new,5) ## # A tibble: 5 x 9 ## ID thickness cell_size cell_shape marg_adhesion epithelial_cell… ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1000… 5 1 1 1 2 ## 2 1002… 5 4 4 5 7 ## 3 1015… 3 1 1 1 2 ## 4 1016… 6 8 8 1 3 ## 5 1017… 4 1 1 3 2 ## # … with 3 more variables: bare_nuclei &lt;dbl&gt;, norm_nucleoli &lt;int&gt;, ## # class &lt;fct&gt; 23.12 Filter Filter est la fonction soeur de select pour les lignes; elle renvoie une copie modifiée qui ne contient que certaines lignes. Cette fonction filtre les ligne en fonction du contenu et des conditions fournies en argument. La fonction filter prend le dataframe comme premier argument. L’argument suivant contient une ou plusieures conditions logiques. Les lignes/observations qui vérifient ces conditions logiques sont retourné(e)s dans le résultat. Dans notre example, on veut garder uniquement les données dont les cellules tuméreuses ont une certaine épaisseur. En pratique on garde celles dont l’épaisseur est supérieure à six, puisque la plupart des tumeurs malignes ont cette épaisseur dans le graphique d’épaisseur de cellule en fonction de la taille de cellule tuméreuse, groupé par classe : library(ggplot2) ggplot(biopsy_new)+ geom_point(aes(x=thickness,y=cell_size,color=class))+ ggtitle(&quot;Plot of Clump Thickness Vs Tumor Cell Size&quot;) #normalize the bare nuclei values biopsy_new&lt;-filter(biopsy_new,thickness&gt;5.5) head(biopsy_new,5) ## # A tibble: 5 x 9 ## ID thickness cell_size cell_shape marg_adhesion epithelial_cell… ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1016… 6 8 8 1 3 ## 2 1017… 8 10 10 8 7 ## 3 1044… 8 7 5 10 7 ## 4 1047… 7 4 6 4 6 ## 5 1050… 10 7 7 6 4 ## # … with 3 more variables: bare_nuclei &lt;dbl&gt;, norm_nucleoli &lt;int&gt;, ## # class &lt;fct&gt; 23.13 Arrange Arrange réordonne les lignes en fonction de leur contenu dans l’ordre croissant par défaut. Les médecins voudraient voir les données dans l’ordre de la taille de la tumeur. #arrange in the order of V2:cell size arrange(biopsy_new,cell_size) ## # A tibble: 186 x 9 ## ID thickness cell_size cell_shape marg_adhesion epithelial_cell… ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1050… 6 1 1 1 2 ## 2 1204… 6 1 1 1 2 ## 3 1223… 6 1 3 1 2 ## 4 5435… 6 1 3 1 4 ## 5 63375 9 1 2 6 4 ## 6 7529… 10 1 1 1 2 ## 7 1276… 6 1 1 3 2 ## 8 1238… 6 1 1 3 2 ## 9 1257… 6 1 1 1 1 ## 10 1224… 6 1 1 1 2 ## # … with 176 more rows, and 3 more variables: bare_nuclei &lt;dbl&gt;, ## # norm_nucleoli &lt;int&gt;, class &lt;fct&gt; Cela montre les données en ordre croissant de la taille de la cellule. Pour organiser les lignes dans l’ordre décroissant de V2, nous ajoutons la fonction desc () à la variable avant de la passer dans arrange. #arrange in the order of V2:cell size in decreasing order arrange(biopsy_new,desc(cell_size)) ## # A tibble: 186 x 9 ## ID thickness cell_size cell_shape marg_adhesion epithelial_cell… ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1017… 8 10 10 8 7 ## 2 1080… 10 10 10 8 6 ## 3 1100… 6 10 10 2 8 ## 4 1103… 10 10 10 4 8 ## 5 1112… 8 10 10 1 3 ## 6 1116… 9 10 10 1 10 ## 7 1123… 6 10 2 8 10 ## 8 1168… 10 10 10 10 10 ## 9 1170… 10 10 10 8 2 ## 10 1173… 10 10 10 3 10 ## # … with 176 more rows, and 3 more variables: bare_nuclei &lt;dbl&gt;, ## # norm_nucleoli &lt;int&gt;, class &lt;fct&gt; Comme vous pouvez le constater, plusieurs lignes ont la même valeur de V2:cell_size. Pour palier ce problème, vous pouvez ajouter une autre variable à utiliser pour l’ordonnencement lorsque la première variable a la même valeur. Ici nous utilisons V3 pour ordonner : par taille de cellule et pas ID : #arrange in the order of V2:cell size biopsy_new&lt;-arrange(biopsy_new,desc(cell_size),desc(cell_shape),ID) head(biopsy_new,5) ## # A tibble: 5 x 9 ## ID thickness cell_size cell_shape marg_adhesion epithelial_cell… ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1017… 8 10 10 8 7 ## 2 1073… 10 10 10 10 6 ## 3 1080… 10 10 10 8 6 ## 4 1100… 6 10 10 2 8 ## 5 1100… 6 10 10 2 8 ## # … with 3 more variables: bare_nuclei &lt;dbl&gt;, norm_nucleoli &lt;int&gt;, ## # class &lt;fct&gt; 23.14 Summarize &amp; Group By Summarize utilise les données pour créer un nouveau dataframe avec les statistiques récapitulatives telles que le minimum, le maximum, la moyenne, etc. Ces statistiques doivent être des fonctions agrégées qui prennent un vecteur de valeurs en entrée et une valeur unique en sortie. La fonction group_by regroupe les données en fonction des valeurs des variables. Ceci, en plus de summarize, fait des observations des groupes de lignes de l’ensemble de données. Les médecins voudraient connaître la taille maximale de la cellule et son épaisseur pour chacune des classes : bénigne et maligne. Cela peut être fait en regroupant les données par classe et en recherchant le maximum des variables cherchées : biopsy_grouped &lt;- group_by(biopsy_new,class) summarize(biopsy_grouped, max(thickness), mean(cell_size), var(norm_nucleoli)) ## # A tibble: 2 x 4 ## class `max(thickness)` `mean(cell_size)` `var(norm_nucleoli)` ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 benign 8 2.67 5.93 ## 2 malignant 10 6.73 11.3 23.15 Pipe Operator Que faire si nous voulons utiliser les différentes fonctions ensemble? Cela pourrait être fait en sauvegardant le résultat de chaque fonction dans une nouvelle variable et en l’utilisant pour la fonction suivante, comme nous l’avons fait ci-dessus. Cependant, ceci n’est pas recommandé : Cela nécessite une saisie supplémentaire et un code plus long. L’espace inutile est utilisé pour sauvegarder les différentes variables. Si les données sont volumineuses, cette méthode ralentit l’analyse. L’opérateur pipe peut être utilisé à la place pour le même but. L’opérateur est placé entre l’objet et la fonction. Le pipe prend l’objet à sa gauche et le passe comme premier argument de la fonction à sa droite. Le pipe fait partie du package magrittr. Cependant, ce package n’a pas besoin d’être chargé car dplyr nous simplifie la vie et l’importe pour nous : biopsy_grouped &lt;- biopsy_new %&gt;% group_by(class) %&gt;% summarize(max(thickness),mean(cell_size),var(norm_nucleoli)) head(biopsy_grouped) ## # A tibble: 2 x 4 ## class `max(thickness)` `mean(cell_size)` `var(norm_nucleoli)` ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 benign 8 2.67 5.93 ## 2 malignant 10 6.73 11.3 23.16 Nettoyer les données transformées Regardez encore une fois les données désordonnées : # Messy Data head(biopsy_new,5) ## # A tibble: 5 x 9 ## ID thickness cell_size cell_shape marg_adhesion epithelial_cell… ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1017… 8 10 10 8 7 ## 2 1073… 10 10 10 10 6 ## 3 1080… 10 10 10 8 6 ## 4 1100… 6 10 10 2 8 ## 5 1100… 6 10 10 2 8 ## # … with 3 more variables: bare_nuclei &lt;dbl&gt;, norm_nucleoli &lt;int&gt;, ## # class &lt;fct&gt; La planification est nécessaire pour décider quelles colonnes nous devons garder inchangées, lesquelles modifier et quels noms doivent être donnés aux nouvelles colonnes. Les colonnes à conserver sont celles qui sont déjà tidy. Les colonnes à modifier sont celles qui ne sont pas de vraies variables mais en réalité des niveaux d’une autre variable. Ainsi, les colonnes ID et la class sont déjà tidy. Celles-ci sont conservées telles quelles. Les colonnes V1:thickness, V2:cell_size, V3:cell_shape, V4:marg_adhesion, V5:epithelial_cell_size, V6:bare_nuclei, et V8:norm_nucleoli ne sont pas de vraies variables mais des valeurs de la variable Tumor_attributes. Nous pouvons résoudre ce problème avec tidyr::gather(), qui est utilisé pour convertir les données messy en tidy. La fonction gather prend le dataframe que nous voulons nettoyer entrée. Les deux paramètres suivants sont les noms des colonnes key et value columns du jeu de données tidy. Dans notre exemple, key = ‘Tumor_Atrributes’ et value = ‘Score’. Vous pouvez également préciser les colonnes que vous ne voulez pas ranger, à savoir ID et class: #Tidy Data library(tidyr) tidy_df &lt;- biopsy_new %&gt;% gather(key = &quot;Tumor_Attributes&quot;, value = &quot;Score&quot;, -ID, -class) tidy_df ## # A tibble: 1,302 x 4 ## ID class Tumor_Attributes Score ## &lt;chr&gt; &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1017122 malignant thickness 8 ## 2 1073960 malignant thickness 10 ## 3 1080185 malignant thickness 10 ## 4 1100524 malignant thickness 6 ## 5 1100524 malignant thickness 6 ## 6 1103608 malignant thickness 10 ## 7 1112209 malignant thickness 8 ## 8 1116116 malignant thickness 9 ## 9 1116116 malignant thickness 9 ## 10 1168736 malignant thickness 10 ## # … with 1,292 more rows 23.17 Liens utiles r4ds on tidy data: C’est toujours mieux d’apprendre de la source, ainsi voici le livre écrit par Hadley Wickham. DataCamp dplyr course: Ce cours couvre les différentes fonctions de dplyr et comment manipuler les données. "],
["missing.html", "24 Données manquantes 24.1 Vue d’ensemble 24.2 tl;dr 24.3 Que sont les NAs? 24.4 Types de Données Manquantes 24.5 Patterns manquants 24.6 Traiter les valeurs manquantes 24.7 External Resources", " 24 Données manquantes Ce chapitre a été réalisé dans le cadre d’une collaboration communautaire créée par ujjwal95 Cette page est en cours de réalisation. Nous apprécions tout commentaire ou feedback. Si vous voulez participez et nous aider à améliorer cette page, vous pouvez contribuer à notre repo. 24.1 Vue d’ensemble Dans cette section, nous verrons plusieurs types de données manquantes et la façon de les traiter. 24.2 tl;dr Il peut être difficile de traiter des données manquantes! S’il manque des données dans nos datasets, ce qui est très souvent le cas, on peut soit s’en débarrasser, soit en déduire la valeur. 24.3 Que sont les NAs? Lorsqu’une donnée dans un rang ou colonne est manquante, elle apparaitra sous de la forme NA. Regardons ça d’un peu plus près: Name Sex Age E_mail Education Income Melissa Female 27 NA NA 1.0e+04 Peter NA NA peter.parker@esu.edu NA 7.5e+03 Aang Male 110 aang@avatars.com NA 1.0e+03 Drake Male NA NA NA 5.0e+04 Bruce NA 45 bruce.wayne@wayne.org NA 1.0e+07 Gwen Female 28 gwen.stacy@esu.edu NA 2.3e+04 Ash Male NA ash.ketchum@pokemon.com NA NA NA NA NA NA NA NA On peut aussi voir le nombre de NAs dans chaque rang et colonne. colSums(is.na(data)) ## Name Sex Age E_mail Education Income ## 1 3 4 3 8 2 rowSums(is.na(data)) ## [1] 2 3 1 3 2 1 3 6 On peut aussi calculer le ratio du nombre de NAs dans chaque rang et colonne: colMeans(is.na(data)) ## Name Sex Age E_mail Education Income ## 0.125 0.375 0.500 0.375 1.000 0.250 rowMeans(is.na(data)) ## [1] 0.3333333 0.5000000 0.1666667 0.5000000 0.3333333 0.1666667 0.5000000 ## [8] 1.0000000 24.4 Types de Données Manquantes Missing Completely at Random (MCAR): Ce sont des valeurs manquantes qui ne sont pas liées à d’autres valeurs, manquantes ou non, du dataset. Missing at Random (MAR): Ce sont des valeurs manquantes qui sont liées à un ou plusieurs autres groupes de données dans le dataset. La bonne nouvelle avec les valeurs manquantes de ce type-là, c’est qu’elles peuvent être déduites (et prédites) par d’autres données présentes dans le dataset. Par exemple, on peut observer que des personnes de plus de 70 ans ont tendance à ne pas donner d’informations sur leur salaire. La plupart des données manquantes à traiter dans la vraie vue sont de ce type-là. Missing Not at Random (MNAR): En général, une donnée manquante qui n’est pas MAR est MNAR. Le problème est cependant qu’il n’y a pas de grande distinction entre les deux. On supposera donc que la donnée manquante est de type MAR à moins que le contraire soit précisé et confirmé par une source extérieure. 24.5 Patterns manquants 24.5.1 Patterns manquants par colonne On peut voir certains patterns manquants dans les données par colonne, ggplot(tidy_names, aes(x = key, y = fct_rev(Name), fill = missing)) + geom_tile(color = &quot;white&quot;) + ggtitle(&quot;Names dataset with NAs added&quot;) + scale_fill_viridis_d() + theme_bw() Et on peut aussi ajouter une échelle de valeur pour vérifier les valeurs numériques disponibles dans le dataset et tenter de trouver des tendances: library(scales) # for legend # Select columns having numeric values numeric_col_names &lt;- colnames(select_if(data, is.numeric)) filtered_for_numeric &lt;- tidy_names[tidy_names$key %in% numeric_col_names,] filtered_for_numeric$value &lt;- as.integer(filtered_for_numeric$value) # Use label=comma to remove scientific notation ggplot(data = filtered_for_numeric, aes(x = key, y = fct_rev(Name), fill = value)) + geom_tile(color = &quot;white&quot;) + scale_fill_gradient(low = &quot;grey80&quot;, high = &quot;red&quot;, na.value = &quot;black&quot;, label=comma) + theme_bw() Est-ce que vous pouvez voir le problème avec le graphe ci-dessus? Avez-vous vu que l’échelle est pour toutes les valeurs, et que donc on ne peut pas voir les différences de niveau entre variables? Pour résoudre ce problème, on peut standardiser les variables: filtered_for_numeric &lt;- filtered_for_numeric %&gt;% group_by(key) %&gt;% mutate(Std = (value-mean(value, na.rm = TRUE))/sd(value, na.rm = TRUE)) %&gt;% ungroup() ggplot(filtered_for_numeric, aes(x = key, y = fct_rev(Name), fill = Std)) + geom_tile(color = &quot;white&quot;) + scale_fill_gradient2(low = &quot;blue&quot;, mid = &quot;white&quot;, high =&quot;yellow&quot;, na.value = &quot;black&quot;) + theme_bw() Maintenant, on peut mieux voir les patterns manquants! Trions-les selon le nombre manquant pour chaque rang et colonne: # convert missing to numeric so it can be summed up filtered_for_numeric &lt;- filtered_for_numeric %&gt;% mutate(missing2 = ifelse(missing == &quot;yes&quot;, 1, 0)) ggplot(filtered_for_numeric, aes(x = fct_reorder(key, -missing2, sum), y = fct_reorder(Name, -missing2, sum), fill = Std)) + geom_tile(color = &quot;white&quot;) + scale_fill_gradient2(low = &quot;blue&quot;, mid = &quot;white&quot;, high =&quot;yellow&quot;, na.value = &quot;black&quot;) + theme_bw() 24.5.2 Patterns manquants par rang On peut aussi voir les patterns manquants dans le dataset par rang en utilisant le package mi: library(mi) x &lt;- missing_data.frame(data) ## Warning in .guess_type(y, favor_ordered, favor_positive, threshold, ## variable_name): Education : cannot infer variable type when all values are ## NA, guessing &#39;irrelevant&#39; ## NOTE: In the following pairs of variables, the missingness pattern of the second is a subset of the first. ## Please verify whether they are in fact logically distinct variables. ## [,1] [,2] ## [1,] &quot;Age&quot; &quot;Income&quot; ## [2,] &quot;Education&quot; &quot;Income&quot; ## Warning in .local(.Object, ...): Some observations are missing on all included variables. ## Often, this indicates a more complicated model is needed for this missingness mechanism image(x) Avez-vous remarqué que la variable Education n’a pas été prise en compte? C’est parce que toute la colonne est manquante. Essayons maintenant de trouver des patterns dans les données manquantes: x@patterns ## [1] E_mail Sex, Age ## [3] nothing Age, E_mail ## [5] Sex nothing ## [7] Age, Income Name, Sex, Age, E_mail, Income ## 7 Levels: nothing E_mail Sex Sex, Age Age, E_mail ... Name, Sex, Age, E_mail, Income levels(x@patterns) ## [1] &quot;nothing&quot; &quot;E_mail&quot; ## [3] &quot;Sex&quot; &quot;Sex, Age&quot; ## [5] &quot;Age, E_mail&quot; &quot;Age, Income&quot; ## [7] &quot;Name, Sex, Age, E_mail, Income&quot; summary(x@patterns) ## nothing E_mail ## 2 1 ## Sex Sex, Age ## 1 1 ## Age, E_mail Age, Income ## 1 1 ## Name, Sex, Age, E_mail, Income ## 1 On peut visualiser les patterns manquants en utilisant la fonction visna (VISualize NA) dans le package extracat: extracat::visna(data) Ici, les rangs représentent un pattern manquant et les colonnes représentent le niveau de la colonne dans laquelle les valeurs sont manquantes. L’avantage de ce graph est qu’il montre seulement les patterns manquants qui sont disponibles dans les données et pas toutes les combinaisons possibles de données (ce qui reviendrait à 2^6 = 64), et on peut donc se concentrer sur le pattern dans les données elles-mêmes. We can sort the graph by most to least common missing pattern (i.e., by row): On peut réarranger le graphe du pattern manquant le plus commun au moins commun. extracat::visna(data, sort = &quot;r&quot;) Ou du plus au moins de valeurs manquantes (ex: par colonne): extracat::visna(data, sort = &quot;c&quot;) Ou on peut également trier par rang et colonne: extracat::visna(data, sort = &quot;b&quot;) 24.6 Traiter les valeurs manquantes il y a plusieurs méthodes pour traiter les valeurs manquantes 24.6.1 Supression des rangs comprenant des NAs Souvent, on supprimera les rangs qui contiennent des NAs lorsqu’on fait face à des données MCR. On peut procéder de la façon suivante: na.omit(data) ## [1] Name Sex Age E_mail Education Income ## &lt;0 rows&gt; (or 0-length row.names) Cette méthode est appelée list-wise deletion. Elle supprime tous les rangs avec des NAs. Mais comme on peut voir que la colonne ‘Education’ ne contient que des NAs, on peut supprimer toute la colonne: edu_data &lt;- data[, !(colnames(data) %in% c(&quot;Education&quot;))] na.omit(edu_data) ## Name Sex Age E_mail Income ## 3 Aang Male 110 aang@avatars.com 1000 ## 6 Gwen Female 28 gwen.stacy@esu.edu 23000 On peut également parler d’une autre méthode appelée pair-wise deletion, avec laquelle seulement les rangs qui possèdent des valeurs manquantes dans la variable d’intérêt seront supprimés. 24.6.2 Technique de prédiction Imputation means to replace missing data with substituted values. These techniques are generally used with MAR data. Une autre possibilité est de remplacer les valeurs manquantes par des valeurs de substitution. Ces techniques sont généralement utilisées avec des données MAR. 24.6.2.1 Substition par la Moyenne/Médiane/Mode On peut remplacer les valeurs manquantes pour des variables continues par leur moyenne ou médiane et les valeurs manquantes pour des variables discrètes ou catégorielles par leur mode. Soit on remplace toutes les valeurs de la variable manquante directement (par exemple, si ‘Income’ a une médiane de 15000, on remplace toutes les variables manquantes de “Income” par 15000) grâce à une technique qu’on appelle Generalized Imputation. Soit on remplace toutes les valeurs sur base de cas similaires. Par exemple, si on remarque les personnes avec Age &gt; 60 ont un salaire beaucoup plus bas que ceux avec Age &lt; 60 en moyenne, on va calculer le salaire médian pour chaque groupe d’Age séparément. Le problème avec ces méthodes cependant est qu’elles perturbent la distribution sous-jacente de nos données. 24.6.3 Prédiction par modèle Il existe plusieurs modèles pour tenter de prédire les données manquantes ainsi que plusieurs packages comme mice, Hmisc, et Amelia II. Pour plus d’info, veuillez lire ce blog sur DataScience+ sur la prédiction de données manquantes avec le package mice en R. 24.7 External Resources Missing Data Imputation - A PDF by the Stats Department at Columbia University regarding Missing-data Imputation How to deal with missing data in R - A 2 min read blogpost in missing data handling in R Imputing Missing Data in R; MICE package - A 9 min read on how to use the mice package to impute missing values in R How to Handle Missing Data - A great blogpost on how to handle missing data. "],
["outliers.html", "25 Outliers 25.1 Vue d’ensemble 25.2 tl;dr 25.3 Que sont outliers? 25.4 Types d’outliers 25.5 Gérer les outliers 25.6 Ressources externes", " 25 Outliers Ce chapitre est à l’origine une contribution de kiransaini En cours de progression. Toute amélioration est la bienvenue. Si vous souhaitez participer rendez vous sur contributing to our repo. 25.1 Vue d’ensemble Cette section explique quels types d’outliers peuvent être rencontrés dans les données et comment les gérer. 25.2 tl;dr Je veux voir des outliers! Les outliers sont difficiles à repérer, car juger qu’un point est un outlier dépend de vos données et du modèle avec lequel il est comparé. Il est important de détecter les outliers car ils peuvent fausser les prévisions et affecter la précision du modèle. 25.3 Que sont outliers? En un mot, les outliers sont très clairement loin du nuage de points. Il peut s’agir d’erreurs, de véritables valeurs extrêmes, de valeurs rares, de valeurs inhabituelles, de cas présentant un intérêt particulier ou de données provenant d’une autre source. Les outliers d’une variable peuvent être repéré individuellement avec des boxplots et les outliers bi-variables peuvent être repérés avec des scatterplots. Il peut aussi y avoir des outliers de plus grande dimension qui ne sont pas outliers dans les dimensions plus petites. Cela vaut la peine d’identifier les outliers pour un certain nombre de raisons. Les mauvais outliers doit toujours être corrigé et de nombreuses méthodes statistiques ne peuvent pas bien fonctionner en présence d’outliers. Néanmoins, un bon outlier peut être intéressant. Regardons le outliers du ‘carat’ variable dans le jeu de donnéé ‘diamond’ : 25.4 Types d’outliers 25.4.1 Outliers univariable Les outliers univariable sont des outliers sur une dimension. L’approche la plus connue pour un premier examen des données consiste à utiliser des boxplots. Tukey suggère de considérer les un point comme outliers s’il est à plus que 1.5 IQR (intervalle inter-quartile) après les lignes (essentiellement le quartiles). Les outliers peuvent changer s’ils sont regroupés avec une autre variable. Examinons les outliers du Sepal.Width variable du jeu de données iris, à la fois lorsque les données sont regroupées par “Species” et quand elles ne le sont pas. Les outliers sont clairement différents : p &lt;- ggplot(iris, aes(x=Species, y=Sepal.Width)) + geom_boxplot(color=&quot;black&quot;, fill=&quot;lightblue&quot;) + ggtitle(&quot;Boxplot for Sepal Width grouped by Species in iris dataset&quot;) p p &lt;- ggplot(iris, aes(y=Sepal.Width)) + geom_boxplot(color=&quot;black&quot;, fill=&quot;lightblue&quot;) + ggtitle(&quot;Boxplot for Sepal Width in iris dataset&quot;) p 25.4.2 Les outliers multivariables Les outliers multivariables sont des outliers sur plus d’une dimension. Les scatterplots et parallel coordinate plots sont utiles pour visualiser des outliers multivariables. Vous pouvez considérer comme outlier un point éloigné de la masse ou bien les points ne rentrant pas dans les courbes modélisant le nuage (smooth curve). Certains points sont des outliers sur les deux critères. Regardons outliers sur les variables “Petal.Length” et “Sepal.Width” du jeu de données ‘iris’. Nous pouvons clairement voir un outlier qui est loin de la masse des données (en bas à gauche): ggplot(iris, aes(x=Sepal.Width, y=Petal.Length)) + geom_point() + ggtitle(&quot;Scatterplot for Petal Length vs Sepal Width in iris dataset&quot;) Regardons outliers sur les variables Petal.Length et Petal.Width dans le jeu de données ‘iris’ en ajustant la smooth curve. Ici, les outliers sont les points qui ne sont pas pris dans le smooth model : ggplot(iris, aes(x=Petal.Width, y=Petal.Length)) + geom_point() + geom_smooth() + geom_density2d(col=&quot;red&quot;,bins=4) + ggtitle(&quot;Scatterplot for Petal Length vs Petal Width in iris dataset&quot;) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Regardons les outliers dans le jeu de données diamond en utilisant un parallel coordinate plot. Nous pouvons voir un outlier sur les variables carat, cut, color, et clarity qui n’est individuellement un outlier dans aucune des variables : library(GGally) ggparcoord(diamonds[1:1000,], columns=1:5, scale=&quot;uniminmax&quot;, alpha=0.8) + ggtitle(&quot;Parallel coordinate plot of diamonds dataset&quot;) 25.4.3 Les outliers catégoriels Les outliers peuvent être rare sur une échelle catégorielles. Néanmoins, certaines combinaisons de catégories sont rares ou ne devraient pas se produire du tout. Les fluctuation diagrams peuvent être utilisés pour trouver de tels outliers. Nous pouvons à titre d’exemple voir des cas rares dans le jeu de données HairEyeColor : library(datasets) library(extracat) fluctile(HairEyeColor) 25.5 Gérer les outliers Identifier des outlies c’est très facile comparé à ce qu’il faut faire après avoir les avoir identifié. Les outliers peuvent être des cas rares, des valeurs inhabituelles ou de véritables erreurs. Les véritables erreurs doivent être corrigées si possible, sinon elles doivent être supprimées. Retirer des outliers est compliqué et requière des connaissances de base. Une stratégie pour traiter les outliers est la suivante : Tracez les distributions 1D des variables en utilisant des boxplots. Examinez toutes les valeurs extremes pour voir si elles sont des valeurs rares ou des erreurs et décider si elles doivent être supprimées ou non. Pour outliers qui sont des valeurs extremes sur une dimension, examinez leurs valeurs sur d’autres dimensions pour décider si elles doivent être supprimées ou non. Ecartez les valeurs qui sont des outliers sur plusieurs dimensions. Considérons les cas qui où l’on a un outlier dans une dimension supérieur mais pas dans une dimension inférieure. Déterminez s’il s’agit ou non d’erreurs et envisagez de les éliminer ou pas. Tracez boxplots et parallel coordinate plots en utilisant le regroupement sur une variable pour trouver outliers dans des sous-ensembles de données. 25.5.1 Sans information Considérons le jeu de données diamonds. Regardons les variables width (y) et depth (z): ggplot(diamonds, aes(y=y)) + geom_boxplot(color=&quot;black&quot;, fill=&quot;#9B3535&quot;) + ggtitle(&quot;Ouliers on width variable in diamonds dataset&quot;) ggplot(diamonds, aes(y=z)) + geom_boxplot(color=&quot;black&quot;, fill=&quot;#9B3535&quot;) + ggtitle(&quot;Ouliers on depth variable in diamonds dataset&quot;) ggplot(diamonds, aes(y, z)) + geom_point(col = &quot;#9B3535&quot;) + xlab(&quot;width&quot;) + ylab(&quot;depth&quot;) 25.5.2 Plus informatif Les graphiques ne sont pas très informatifs en raison des outliers. Les mêmes graphiques après filtrage des outliers sont beaucoup plus informatifs: d2 &lt;- filter(diamonds, y &gt; 2 &amp; y &lt; 11 &amp; z &gt; 1 &amp; z &lt; 8) ggplot(d2, aes(y=y)) + geom_boxplot(color=&quot;black&quot;, fill=&quot;lightblue&quot;) + ggtitle(&quot;Ouliers on width variable in diamonds dataset&quot;) d2 &lt;- filter(diamonds, y &gt; 2 &amp; y &lt; 11 &amp; z &gt; 1 &amp; z &lt; 8) ggplot(d2, aes(y=z)) + geom_boxplot(color=&quot;black&quot;, fill=&quot;lightblue&quot;) + ggtitle(&quot;Ouliers on depth variable in diamonds dataset&quot;) d2 &lt;- filter(diamonds, y &gt; 2 &amp; y &lt; 11 &amp; z &gt; 1 &amp; z &lt; 8) ggplot(d2, aes(y, z)) + geom_point(shape = 21, color = &quot;darkGrey&quot;, fill = &quot;lightBlue&quot;, stroke = 0.1) + xlab(&quot;width&quot;) + ylab(&quot;depth&quot;) 25.6 Ressources externes Identify, describe, plot, and remove the outliers from the dataset: Afficher et retirer les outliers d’un jeu de données A Brief Overview of Outlier Detection Techniques: Discussion théorique sur la détection d’outliers. "],
["dates.html", "26 Dates dans R 26.1 Introduction 26.2 Convertir en la classe Date 26.3 Travaillez avec la classe Date 26.4 Tracez des graphes avec une variable de classe Date 26.5 Date and time classes", " 26 Dates dans R 26.1 Introduction Travailler avec des dates peut être très frustrant. En général, le mieux est de travailler avec la classe de données la plus facile. Cela signifie par exemple que si la variable avec laquelle on travaille est en années, le mieux est d’en faire un integer; il n’y a pas de raison d’en faire une variable de la classe date ou date-time. Si par contre, ce n’est pas possible d’utiliser une de ces classes simplifiées, on peut utiliser la classe Date dans R. 26.2 Convertir en la classe Date On peut convertir une variable de classe character en une variable de classe Dateen utilisant as.Date(): dchar &lt;- &quot;2018-10-12&quot; ddate &lt;- as.Date(dchar) Notez que les deux apparaissent de la même manière, même si leur classe est différente. dchar ## [1] &quot;2018-10-12&quot; ddate ## [1] &quot;2018-10-12&quot; class(dchar) ## [1] &quot;character&quot; class(ddate) ## [1] &quot;Date&quot; Si la date n’a pas le format YYYY-MM-DD ou YYYY/MM/DD, il faudra spécifier le format dans lequel on souhaite convertir la nouvelle variable de classe Date en utilisant le symbole % de la façon suivante: as.Date(&quot;Thursday, January 6, 2005&quot;, format = &quot;%A, %B %d, %Y&quot;) ## [1] &quot;2005-01-06&quot; Pour une liste de toutes les spécifications possibles dans R, voir ?strptime. Tidyverse lubridate rend la conversion de dates qui ne sont pas dans un format standard très facile grâce aux fonctions ymd(), ydm(), mdy(), myd(), dmy(), dym() et autres. lubridate::mdy(&quot;April 13, 1907&quot;) ## [1] &quot;1907-04-13&quot; Essayez as.Date(&quot;April 13, 1907&quot;) et vous verrez les avantages d’utiliser une fonction lubridate. 26.3 Travaillez avec la classe Date Cela vaut clairement la peine de convertir des variables en la classe Date car on peut faire beaucoup de choses avec ce genre de variable qu’on ne pourrait pas faire si on les avait laissés en character. Nombre de jours entre deux dates: as.Date(&quot;2017-11-02&quot;) - as.Date(&quot;2017-01-01&quot;) ## Time difference of 305 days Comparer deux dates: as.Date(&quot;2017-11-12&quot;) &gt; as.Date(&quot;2017-3-3&quot;) ## [1] TRUE Notez que Sys.Date() renvoie la date d’aujourd’hui en une variable de classe Date: Sys.Date() ## [1] &quot;2019-10-31&quot; class(Sys.Date()) ## [1] &quot;Date&quot; R a des fonctions pour extraire des informations particulières à partir d’une date: today &lt;- Sys.Date() weekdays(today) ## [1] &quot;Thursday&quot; weekdays(today, abbreviate = TRUE) ## [1] &quot;Thu&quot; months(today) ## [1] &quot;October&quot; months(today, abbreviate = TRUE) ## [1] &quot;Oct&quot; quarters(today) ## [1] &quot;Q4&quot; Le package lubridate procure des fonctions additionnelles pour extraire plus d’information à partir d’une date de classe Date: today &lt;- Sys.Date() lubridate::year(today) ## [1] 2019 lubridate::yday(today) ## [1] 304 lubridate::month(today) ## [1] 10 lubridate::month(today, label = TRUE) ## [1] Oct ## 12 Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; ... &lt; Dec lubridate::mday(today) ## [1] 31 lubridate::week(today) ## [1] 44 lubridate::wday(today) ## [1] 5 26.4 Tracez des graphes avec une variable de classe Date On peut travailler avec base R graphics et ggplot2, les deux peuvent travailler avec une variable de la classe Date et nommer les axes correctement: 26.4.1 base R df &lt;- read.csv(&quot;data/mortgage.csv&quot;) df$DATE &lt;- as.Date(df$DATE) plot(df$DATE, df$X5.1.ARM, type = &quot;l&quot;) # on the order of years plot(df$DATE[1:30], df$X5.1.ARM[1:30], type = &quot;l&quot;) # switch to months Notez le changement des labels de l’axe x dans le deuxième graphe. 26.4.2 ggplot2 # readr library(tidyverse) Notez que contrairement à read.csv() de base R, readr::read_csv() lit automatiquement DATE comme une variable de classe Date par ce que cette variable est déjà sous la forme YYYY-MM-DD: df &lt;- readr::read_csv(&quot;data/mortgage.csv&quot;) ## Parsed with column specification: ## cols( ## DATE = col_date(format = &quot;&quot;), ## `5/1 ARM` = col_double(), ## `15 YR FIXED` = col_double(), ## `30 YR FIXED` = col_double() ## ) g &lt;- ggplot(df, aes(DATE, `30 YR FIXED`)) + geom_line() + theme_grey(14) g ggplot(df %&gt;% filter(DATE &lt; as.Date(&quot;2006-01-01&quot;)), aes(DATE, `30 YR FIXED`)) + geom_line() + theme_grey(14) A nouveau, lorsque les données sont filtrées, les labels de l’axe x changent de years à months. 26.4.2.1 Breaks, limits, labels On peut contrôler les breaks, limits et labels de l’axe x grâce à scale_x_date(): library(lubridate) g + scale_x_date(limits = c(ymd(&quot;2008-01-01&quot;), ymd(&quot;2008-12-31&quot;))) + ggtitle(&quot;limits = c(ymd(\\&quot;2008-01-01\\&quot;), ymd(\\&quot;2008-12-31\\&quot;))&quot;) g + scale_x_date(date_breaks = &quot;4 years&quot;) + ggtitle(&quot;scale_x_date(date_breaks = \\&quot;4 years\\&quot;)&quot;) g + scale_x_date(date_labels = &quot;%Y-%m&quot;) + ggtitle(&quot;scale_x_date(date_labels = \\&quot;%Y-%m\\&quot;)&quot;) (Oui, même dans le package tidyverse on ne peut pas complètement échapper à l’utilisation de % pour convertir les formats des dates. Pour rappel, ?strptime si besoin d’aide). 26.4.2.2 Annotations On peut utiliser geom_vline() et `annotate() pour marquer des événements spécifiques dans une série temporelle: ggplot(df, aes(DATE, `30 YR FIXED`)) + geom_line() + geom_vline(xintercept = ymd(&quot;2008-09-29&quot;), color = &quot;blue&quot;) + annotate(&quot;text&quot;, x = ymd(&quot;2008-09-29&quot;), y = 3.75, label = &quot; Market crash\\n 9/29/08&quot;, color = &quot;blue&quot;, hjust = 0) + scale_x_date(limits = c(ymd(&quot;2008-01-01&quot;), ymd(&quot;2009-12-31&quot;)), date_breaks = &quot;1 year&quot;, date_labels = &quot;%Y&quot;) + theme_grey(16) + ggtitle(&quot;`geom_vline()` with `annotate()`&quot;) 26.5 Date and time classes Sys.time() ## [1] &quot;2019-10-31 07:53:54 EDT&quot; "],
["percept.html", "27 Perception/Couleur 27.1 Vue d’ensemble 27.2 Perception 27.3 Couleur 27.4 Astuces pour utiliser les couleurs avec ggplot2", " 27 Perception/Couleur 27.1 Vue d’ensemble Cette section contient des ressources pour en savoir plus sur la perception graphique et sur l’utilisation efficace des couleurs. 27.2 Perception Voici quelques liens vers des ouvrages / articles clés sur la perception: Graphical Perception: Theory, Experimentation, and Application to the Development of Graphical Methods: Article classique de William Cleveland and Robert McGill The Elements of Graphing Data: Textbook by William Cleveland Visualizing Data: Livre écrit par William Cleveland Creating More Effective Graphs: Livre écrit par by Naomi Robbins 27.3 Couleur La couleur est très subjective. Il est important de faire les bons choix de couleur pour que votre travail soit facile à comprendre. Color Brewer: Excellente ressource pour obtenir des palettes de couleurs efficaces pour vos différents projets. Son objectif principal est la cartographie, mais il est extrêmement utile pour tout projet impliquant la couleur. Vous pouvez choisir entre différents types de données (sequentielles, divergentes, qualitative). Assurez-vous que la palette choisie est efficace pour les utilisateurs daltoniens (ou bien rendez possible une impression simplifiée ou photocopie adaptée), et exporter facilement la palette de couleurs dans différents formats (Adobe, GIMP / Inkscape, JS, CSS). Color Blindness Simulator: Vous ne savez pas si votre choix de couleur sera adapté pour un utilisateur daltonien ? Cet outil peut aider. Vous pouvez télécharger une image pour voir son apparence avec différents handicaps liés à la vision des couleurs. ColorPick Eyedropper: Cette extension Chrome vous permet de copier les valeurs hexadécimales des couleurs sur une page Web. Simple et intuitif, il sera beaucoup plus facile de créer vous-mêmes vos superbes palettes de couleurs. 27.4 Astuces pour utiliser les couleurs avec ggplot2 L’un des problèmes les plus courants est la confusion entre color et fill. geom_point() et geom_line utilisent color, de nombreux autres geoms utilisent fill. Certains utilisent les deux, tels que geom_tile(), auquel cas color est la couleur de la bordure et fill est la couleur de remplissage. 27.4.1 Données continues 27.4.1.1 ColorBrewer scale_color_distiller(palette = &quot;PuBu&quot;) or scale_fill_distiller(palette = &quot;PuBu&quot;) (What doesn’t work: scale_color_brewer(palette = &quot;PuBu&quot;)) 27.4.1.2 Viridis scale_color_viridis_c() or scale_fill... (the c stands for continuous) 27.4.1.3 Créer la votre + scale_color_gradient(low = &quot;white&quot;, high = &quot;red&quot;) or + scale_fill... + scale_color_gradient2(low = &quot;red&quot;, mid = &quot;white&quot;, high = &quot;blue&quot;, midpoint = 50) or + scale_fill... + scale_color_gradientn(colours = c(&quot;red&quot;, &quot;pink&quot;, &quot;lightblue&quot;, &quot;blue&quot;)) or scale_fill... 27.4.2 Données discrètes 27.4.2.1 ColorBrewer scale_color_brewer(palette = &quot;PuBu&quot;) or scale_fill... 27.4.2.2 Viridis scale_color_viridis_d() or scale_fill... (the d stands for discrete) 27.4.2.3 Créer la votre + scale_color_manual(values = c(&quot;red&quot;, &quot;yellow&quot;, &quot;blue&quot;)) or scale_fill... + scale_fill_manual(values = c(&quot;red&quot;, &quot;yellow&quot;, &quot;blue&quot;)) or scale_fill... "],
["themes.html", "28 Thèmes et Palettes 28.1 Vue d’ensemble 28.2 Thèmes ggplot2 28.3 RColorBrewer 28.4 ggthemes 28.5 ggthemr 28.6 ggsci 28.7 Ressources externes", " 28 Thèmes et Palettes Ce chapitre a été réalisé dans le cadre d’une collaboration communautaire crée par ar3879 *Cette page est un travail en cours. Nous apprécions tout commentaire ou feedback. Si vous souhaitez améliorer cette page, vous pouvez participer à notre repo. 28.1 Vue d’ensemble Nos graphiques doivent non seulement être informatifs mais aussi esthétiques pour obtenir l’attention de notre public. Les thèmes et les couleurs utilisées ont un rôle important à jouer quant à l’esthétique des graphiques. Cette section explique comment utiliser différentes palettes et thèmes selon le contexte et comment rendre nos graphiques cools. 28.2 Thèmes ggplot2 ggplot2 offre un ensemble de thème que nous pouvons choisir pour nos graphiques. Vous trouverez ci-dessous une brève description de chacun: theme_gray(): thème signature de ggplot2 theme_bw(): thème noir et blanc de ggplot2 theme_linedraw(): lignes noires sur fond blanc uniquement theme_light(): similaire à linedraw() mais avec des lignes grises également theme_dark(): lignes sur un fond foncé plutôt que clair theme_minimal(): pas d’annotations sur le fond du graphique theme_classic(): thème sans grillage theme_void(): thème vide sans aucun élément 28.2.1 exemples de thèmes ggplot q &lt;- ggplot(subset, aes(x = clarity, y = carat, color = cut)) + geom_point(size = 2.5,alpha = 0.75) q + theme_minimal() Il y a plusieurs autres packages disponibles qui permettent de modifier les thèmes et couleurs de plusieurs façons différentes. Nous discuterons 4 d’entre-eux. RColorBrewer ggthemes ggthemr ggsci 28.3 RColorBrewer Souvent, on cherche des couleurs qui rendront notre graphique clair et cool. RColorBrewer offre une multitude de palettes que nous pouvons utiliser en fonction du contexte de notre graphique. Il y a trois catégories de palettes: Sequential, Diverging et Qualitative. q &lt;- ggplot(subset, aes(x = clarity, y = carat, color = cut)) + geom_point(size = 2.5, alpha = 0.75) Sequential Palette: Cette palette représente la nuance de la couleur, de clair à foncé. On l’utilise en général pour représenter un interval de données pour lequel les valeurs basses seront représentées par une couleur claire et les valeurs élevées par une couleur foncée. On citera comme exemples: Blues, BuPu, YlGn, Reds, OrRd. q + scale_colour_brewer(palette = &quot;Blues&quot;) Diverging Palette: Cette palette présente trois couleurs ou plus qui divergent totalement (par exemple du bleu, du blanc et du rouge) pour permettre d’établir des contrastes entre données plus facilement. On citera par exemple:Spectral, RdGy, PuOr q + scale_colour_brewer(palette = &quot;PuOr&quot;) Qualitative Palette: Cette palette est généralement utilisée lorsque l’on veut souligner les différences entre classes de variables (variables catégorielles). On citera par exemple: set1, set2, set3, pastel1, pastel2 , dark2. q + scale_colour_brewer(palette = &quot;Pastel1&quot;) 28.4 ggthemes ggthemes élargit le choix de geoms, scales et thèmes de ggplot2. Certains sont vraiment très sympas! On peut changer le thème et la couleur du graphique en fonction du contexte. g1 &lt;- ggplot(subset, aes(x = clarity, y = carat, color = cut)) + geom_point(size = 2.5,alpha = 0.75) 28.4.1 exemples de ggthemes g1 + theme_economist() + scale_colour_economist() g1 + theme_igray() + scale_colour_tableau() g1 + theme_wsj() + scale_color_wsj() g1 + theme_igray() + scale_colour_colorblind() Si on veut utiliser ces couleurs dans nos graphiques mais qu’il n’est pas possible d’utiliser ggthemes, on peut utiliser le package scales pour trouver quelles couleurs ont été utilisées dans une palette donnée. Par exemple: show_col(colorblind_pal()(6)) 28.5 ggthemr ggthemr est utilisé pour déterminer le thème des graphiques ggplot. Il y a 17 thèmes différents pour changer la façon de présenter un graphique ggplot. L’utilisation de ggthemr est cependant différente des autres packages: on décide du thème avant de l’utiliser. 28.5.1 exemples ggthemr ggthemr(&quot;sky&quot;) ## Warning: New theme missing the following elements: axis.ticks.length.x, ## axis.ticks.length.x.top, axis.ticks.length.x.bottom, axis.ticks.length.y, ## axis.ticks.length.y.left, axis.ticks.length.y.right, plot.title.position, ## plot.caption.position ggplot(subset, aes(x = clarity, y = carat, color = cut)) + geom_point(size = 2.5, alpha = 0.75) ggthemr(&quot;flat&quot;) ## Warning: New theme missing the following elements: axis.ticks.length.x, ## axis.ticks.length.x.top, axis.ticks.length.x.bottom, axis.ticks.length.y, ## axis.ticks.length.y.left, axis.ticks.length.y.right, plot.title.position, ## plot.caption.position ggplot(subset, aes(x = clarity, y = carat, color = cut)) + geom_point(size = 2.5, alpha = 0.75) On peut également définir plus de paramètres pour changer les thèmes: ggthemr(&quot;lilac&quot;, type = &quot;outer&quot;, layout = &quot;scientific&quot;, spacing = 2) ## Warning: New theme missing the following elements: axis.ticks.length.x, ## axis.ticks.length.x.top, axis.ticks.length.x.bottom, axis.ticks.length.y, ## axis.ticks.length.y.left, axis.ticks.length.y.right, plot.title.position, ## plot.caption.position ggplot(subset, aes(x = clarity, y = carat, color = cut)) + geom_point(size = 2.5, alpha = 0.75) 28.6 ggsci ggsci offers a number of palettes inspired by colors used in scientific journals, science fiction movies, and TV shows. For continous data, scale_fill_material(colname) is used, and for discrete data, scale_color_palname() or scale_fill_palname() are used. ggsci offrent un nombre de palettes inspirées de couleurs utilisées dans les journaux scientifiques, films de science fiction et séries télévisées. Pour des données continues, on utilise scale_fill_material() et pour des données discères, scale_color_palname() ou scale_fill_palname() sont utilisées. 28.6.1 ggsci pour données discrètes # we need to remove the theme set previously if we don&#39;t want to use it anymore ggthemr_reset() g1 &lt;- ggplot(subset, aes(x = clarity, y = carat, color = cut)) + geom_point(size = 2.5, alpha = 0.75) g1 + scale_color_startrek() g1 + scale_color_jama() g1 + scale_color_locuszoom() 28.6.2 ggsci pour données continues ggplot(diamonds, aes(carat, price)) + geom_hex(bins = 20, color = &quot;red&quot;) + scale_fill_material(&quot;orange&quot;) On peut aussi retrouver la couleur utilisée afin de la réutiliser dans d’autres graphiques créés avec base R: palette = pal_lancet(&quot;lanonc&quot;, alpha = 0.7)(9) show_col(palette) 28.7 Ressources externes RColorBrewer: Setting up Color Palettes in R ggthemes: Github page containing more examples ggthemr: Github Repository of the package ggsci: Scientific Journal and Sci-Fi Themed Color Palettes for ggplot2 "],
["github.html", "29 GitHub/git Resources 29.1 Vue d’ensemble 29.2 Tout d’abord 29.3 Le workflow sans branche 29.4 Votre repo avec branche 29.5 1ère PR sur un autre repo avec branching 29.6 2ème-nème PR sur un autre repo avec branching 29.7 Infos Git qui peuvent être utiles 29.8 Autres ressources", " 29 GitHub/git Resources 29.1 Vue d’ensemble Cette section décrit les différents workflows pour travailler avec Github/git et donne des conseils sur comment collaborer en équipe sur de grands projects de programmation. Si vous voulez apprendre comment proposer des changements au livre edav.info (ou n’importe quel autre repo) sans quitter github.com, veuillez vous référer au chapitre Contribuer à cette ressource. Ok, pas satisfait de supprimer des futes de frappes sur GitHub? Vous êtes prêts à travailler localement et modifier du code entre vos repos (ou ceux de quelqu’un d’autre) et votre machine? Pour cela, vous aurez besoin de Git, un système de contrôle de version très répandu. C’est très puissant et utile, mais aussi très agaçant et difficile à comprendre. Plutôt que d’essayer de maîtriser tout le système, on suggère de commencer avec des workflows plutôt basiques, comme ceux expliqués ci-dessous. On peut en tirer beaucoup de profit sans être un expert pour autant. 29.2 Tout d’abord Installer Git Pour se faire, suivre les instructions dans le chapitre Install Git de Happy Git with R. Entrez votre nom et votre adresse mail. Introduce yourself to Git in Happy Git explique comment faire. (Optionel) Assurez-vous que vous pouvez lancer des pulls et pushs entre Github et votre ordinateur Connect to GitHub 29.3 Le workflow sans branche Pour vous familiariser avec Git, commencez par ce workflow basique dans lequel vous allez pull de et push vers votre repo sur Github. Cela reste entre vous, sans collaboration avec personne: Le chapitre Connect RStudio to Git and GitHub de Happy Git vous aidera à commencer: vous allez créer un repo su GitHub, cloner le repo dans un projet RStudio, et faire des changements. Une fois que tout est prêt, votre workflow local sera pull, work, commit/push PULL A chaque fois que vous ouvrez RStudio et choisissez le projet, vous ‘pullerez’ tous les changements faits sur le repo en clickant sur la Flèche vers le bas dans le panel Git dans RStudio. Vous pouvez penser qu’aucun changement n’a été fait et qu’il n’y a rien à ‘pull’, mais vous pouvez oublier les fautes de frappe que vous avez corrigé en ligne et c’est une bonne chose de toujours commencer par ‘pull’ au cas où. TRAVAILLEZ Faites ce que vous avez à faire, faites des changements dans vos fichiers, ajoutez-en des nouveaux, etc. Gardez un oeil sur le panel Git dans RStudio: il vous montrera quels fichiers ont été modifiés. COMMIT/PUSH Quand vous avez fini de travailler, il faut décider de ce qu’on fait avec les fichiers qui ont été modifiés. Si vous aimez comme nous garder un panel Git propre, vous avez trois options pour chaque fichier: 1) Clicker sur “Staged” pour préparer le fichier à être envoyer sur GitHub; 2) Supprimer le fichier si on n’en a pas besoin, 3) Ajouter le fichier à .gitignore s’il s’agit d’un fichier que vous souhaitez garder localement sans l’envoyer sur GitHub. (Gardez à l’esprit que les fichiers dans .gitignore ne sont pas sauvegardés à moins que vous auez un autre système de backup.). L’étape suivante est de clicker sur le bouton Commit et ajouter un message qui décrit ce qui a été changé. Enfin, clickez sur la Flèche du Haut pour envoyer le commit sur GitHub. Ce n’est pas une bonne idée de commit trop souvent mais si vous êtes débutants, cela peut être utile pour apprendre comme ça fonctionne. 29.4 Votre repo avec branche Une fois que vous êtes à l’aise avec le workflow décrit ci-dessus, vous êtes prêt à commencer le branching. Le procédé est similaire que l’on travaille sur son propre repo ou sur celui de quelqu’un d’autres. S’il s’agit de votre repo, vous pouvez suivre les étapes énoncées dans ces slides, qui expliquent pas-à-pas comment créer une branche, travailler dessus et envoyer une demande de pull pour fusionner les changements sur l’origin/master. Ou vous pouvez suivre les étapes suivantes, en passant les étapes 1 et 3. 29.5 1ère PR sur un autre repo avec branching Etape 1: ‘Fork’ le repo ‘upstream’ (une seule fois) Passez cette étape si vous êtes en sync avec votre propre repo, c’est-à-dire que vous avez créé le repo et vous ne clonez pas une fork du repo quelqu’un d’autre. Supposons que vous souhaitiez contribuer à EDAV! ‘Forkez’ notre repo GitHub, puis, sur votre propre page GitHub, vous verrez un repo ** EDAV ** dans la section ‘repositories’. Notez qu’à partir de maintenant, le terme ** repo upsteam ** fait référence au repo d’origine du projet que vous avez forké et le terme ** repo d’origine ** fait référence au repo que vous avez créé ou forké sur GitHub. De votre point de vue, ** upstream ** et ** origine ** sont tous deux des repos dit “remote”. A fork of jtr13/EDAV Etape 2: Clonez le repo d’origine et créez un repo local (une fois) Un ** repo local ** est le repo résidant sur votre ordinateur. Pour pouvoir travailler localement, nous devons créer une copie locale du repo ‘remote’. Comme nous avons déjà connecté git à RStudio, nous pouvons créer un repo local de la manière suivante. Dans RStudio, cliquez sur Fichier -&gt; Nouveau projet -&gt; Contrôle de version -&gt; ** Git. Vous pouvez maintenant renseigner l’URL du repo d’origine ** et cliquer sur Create Project pour créer un repo local. Etape 3: Configurez le repo ‘remote’ qui est relié au repo ‘upstream’ (une fois) Ignorez cette étape si vous synchronisez avec votre propre repo. Le but de cette étape est de spécifier l’emplacement du repo ‘upstream’, c’est-à-dire le projet d’origine, pas votre copie. Pour compléter cette étape, tapez la ligne de commande suivante: &gt; git remote add upstream &lt;upstream repo url&gt; Source: Configuring a remote for a fork Etape 4: Branch Avec ce workflow, tout nouveau travail est effectué sur une branche. Il est donc important de ne pas oublier de créer une nouvelle branche avant de commencer à travailler. Une fois le travail terminé, une ‘pull request’ est soumise et si tout se passe bien, le nouveau code sera fusionné dans la branche principale du projet sur GitHub. Lorsque vous êtes prêt à commencer à travailler sur quelque chose de nouveau, créez une nouvelle branche. Ne réutilisez pas une branche fusionnée. Chaque “fix” devrait avoir sa propre branche et être supprimé après avoir été fusionné. Pour créer une branche, cliquez sur le bouton présenté ci-dessous: Donnez à votre nouvelle branche un nom significatif. Par exemple, si vous avez l’intention d’ajouter un exemple de facet au chapitre sur les histogrammes, vous pouvez appeler votre branche add_hist_facet. Laissez la case “Sync branche with remote” cochée. Ainsi, vous créerez non seulement une branche locale, mais également une branche ‘remote’ sur l’origine et la branche locale sera configurée pour suivre la branche remote. En bref, ils seront liés et git prendra note de tout changement de l’un ou l’autre. Etape 5: Travaillez, commit et push Lorsque vous créez une branche en suivant la méthode décrite à l’étape 4, vous serez automatiquement envoyés sur la nouvelle branche. Vous pouvez changer de branche en cliquant sur la liste déroulante située à droite du bouton de la nouvelle branche. Cependant, faites bien attention lorsque vous le faites. Les travaux non commit, même s’ils sont sauvegardés, n’appartiennent pas à une branche et sont donc déplacés avec vous lorsque vous changez de branche. On peut donc facilement être sur la mauvaise branche. Vérifiez toujours que vous êtes au bon endroit et pendant que vous travaillez, gardez un œil sur les fichiers modifiés dans le panel Git. Rappelez-vous les trois étapes pour déplacer un travail sauvegardé de votre directory vers GitHub, représentées par les commandes git: add,commit et push. Dans RStudio, pour add, il vous suffit de cliquer sur la case à cocher de chaque fichier que vous avez modifié dans la colonne “staged” située à gauche du volet Git. Pour commit, il suffit de cliquer sur le bouton commit sous l’onglet Git. La saisie d’un message commit est obligatoire. choisissez une description en lien avec les modifications du code. Enfin, pour appliquer les modifications à GitHub, cliquez sur le bouton push, qui est représenté par une flèche pointant vers le haut. Vous pouvez combiner plusieurs commits en un “push”. Il n’est pas considéré comme bon de commit trop souvent, car tous les commits sont entrés dans l’historique des commits et il est difficile de trouver ce dont vous avez besoin si vous ‘commit’ votre travail toutes les cinq minutes. (Au début, cependant, ne vous en faites pas. Il est plus important d’utiliser les commandes fréquemment pour acquérir de l’expérience.) Le chapitre Repeated Amend de Happy Git with R décrit une approche pour traiter de la fréquence des commits. Etape 6: Envoyer une pull request Vous pouvez maintenant voir la branche que vous avez créée sur la page GitHub. L’étape suivante consiste à soumettre une pull request. Le processus est très similaire au processus décrit dans GitHub only walkthrough, en commençant par l’étape 6. Etape 7: Fusionner la pull request Si vous avez soumis un PR à un autre projet, vous n’êtes pas celui qui va fusionner la PR. Vous n’avez donc rien à faire ici. S’il s’agit de votre projet et qu’il vous incombe de le faire, sachez qu’il existe de nombreuses méthodes pour fusionner une demande. La plus simple et directe consiste à fusionner le PR sur GitHub. Cette méthode fonctionne bien pour la fusion de fautes de frappe fixes. Si vous souhaitez pouvoir tester le code, vous pouvez vérifier le PR localement, le tester et même éventuellement le modifier avant de le fusionner. Les meilleures pratiques dans ce domaine évoluent. Notre recommandation actuelle est d’utiliser le paquetage usethis, qui simplifie énormément les tâches complexes. “Comment modifier une demande d’extraction localement” explique comment procéder. Une autre ressource intéressante est “Explore and extend a pull request” dans Happy Git with R. Ce chapitre décrit deux versions officielles de GitHub qui permettent de fusionner un pull request, ainsi qu’un workflow en développement en utilisant git2r. 29.6 2ème-nème PR sur un autre repo avec branching Après la première pull request, le processus change un peu. Nous n’avons plus besoin de bifurquer et de cloner le repo. Ce que nous devons faire, cependant, est de nous assurer que notre copie locale du repo est à jour avec la version de GitHub. Nous devons effectuer d’autres opérations de nettoyage. Par conséquent, après la première pull request, nous remplacerons les étapes 1 à 3 ci-dessus par les opérations suivantes: Step 1: Synchroniser La façon dont vous synchronisez dépend de si vous synchronisez avec votre propre repo (“origine”) ou celui de quelqu’un d’autre (“upstream”). Cela devrait être fait au début de chaque session de travail. Votre repo Allez sur la branche principale (important!), puis cliquez sur le bouton Pull (flèche vers le bas) de le panel Git de RStudio. Ou vous pouvez taper ce qui suit dans le terminal: &gt; git checkout master &gt; git pull Il n’y aura pas de rappel vous prévenant que vous êtes en retard, alors c’est à vous de décider. Faites-en une habitude. Le repo de quelqu’un d’autre Si vous travaillez sur le repo de quelqu’un d’autre, assurez-vous que vous avez configuré un repo upstream. Faites ensuite ce qui suit pour updater votre fork: &gt; git fetch upstream &gt; git checkout master &gt; git merge upstream/master Source: Syncing a fork Notez que ces commandes apportent des modifications directement à partir du repo upstream. Etape 2: Supprimer l’ancienne branche Si votre pull request précédente a été fusionnée, il est recommandé de supprimer la branche associée, car l’upstream contient déjà toutes les modifications que vous avez apportées. Pour supprimer complètement une branche, vous devez 1) supprimer la branche locale, 2) supprimer la branche distante, 3) cesser de suivre la branche: Une façon de supprimer la branche remote est de le faire sur GitHub. Accédez à la pull request fermée sur le repo upstream. Si votre branche a été fusionnée, la boîte de dialogue de pull request affiche le message suivant: “Vous avez terminé - la branche&lt;nom de la branche&gt;peut être supprimée en toute sécurité.” Cliquez simplement sur le bouton Supprimer la branche à côté du message. Si vous préférez travailler dans le terminal, vous pouvez supprimer la branche distante avec: &gt; git push origin --delete &lt;branchname&gt; Pour supprimer la branche locale, passez à la branche principale dans RStudio puis tapez ce qui suit dans le terminal: &gt; git branch -d branchname Notez que git n’arrête pas de suivre la branche remote même si elle est supprimées des deux endroits! Pour arrêter de suivre les branches supprimées, utilisez les éléments suivants: &gt; git fetch -p Sinon, vous verrez toujours les branches supprimées répertoriées dans le panel Git de RStudio, et elles apparaîtront quand même lorsque vous regarderez toutes vos branches avec la fonction suivante: &gt; git branch -a (* = checked out branch) En parlant de cela, sachez que le panel Git n’a pas tendance à se mettre à jour en temps réel. Vous verrez donc probablement toujours les branches supprimées. Veillez à ne pas être envoyés dessus, ou vous les recréerez par inadvertance. (Les branches supprimées ont l’habitude de revenir.) Un clic sur master (même si vous êtes déjà dessus) apparaît pour déclencher une mise à jour de la liste déroulante. Si cela ne fonctionne pas, le fait de quitter le projet et d’y revenir le fera si vous voulez être sûr que les branches que vous avez supprimées le sont vraiment. Troubleshooting Assurez-vous de ne pas être sur la branche que vous essayez de supprimer. Notez que si vous essayez de supprimer une branche qui n’a pas été complètement fusionnée, vous recevrez un avertissement, ou peut-être une erreur en fonction de ce qui s’est passé. Il est possible qu’il pense juste que la branche n’a pas été fusionnée alors que vous l’avez fait, car vous n’êtes pas à jour. On peut y remédier avec git pull. Dans les autres cas, vous devrez suivre les instructions pour utiliser -D au lieu de-d, par exemple, si vous décidez d’abandonner et de supprimer une branche sans soumettre de pull request. Si vous avez du mal à vous débarrasser des branches, rassurez-vous, vous n’êtes pas seul. [Comment puis-je supprimer une branche Git localement et à distance?] _blank&quot;} est la **troisième question la plus posée{target =&quot;_blank&quot;}** sur StackOverflow! Etape 3: Mettre à jour votre fork sur GitHub Ignorez cette étape s’il n’y a pas de repo upstream. Oui, c’est étrange, mais une fois que vous avez créé et cloné le repo du projet, la copie sur GitHub devient relativement inutile. Cependant, ce n’est pas une mauvaise idée de la garder à jour, ne serait-ce que parce qu’il est dérangeant de voir des messages comme celui-ci dans votre panel Git: Heureusement, votre fork de GitHub peut être facilement mis à jour en cliquant sur la flèche verte vers le haut ou en entrant «git push» dans le terminal. Etapes 4-7: Voir ci-dessus Nous sommes maintenant prêts à répéter le worklow: branche, travail, commit, push, pull request. Pour ce faire, suivez Étapes 4 à 7 ci-dessus. 29.7 Infos Git qui peuvent être utiles 29.7.1 Supprimer le dernier commit git reset --soft HEAD~1 29.7.2 Supprimer tous les changements depuis le dernier commit git reset HEAD --hard 29.7.3 Oublier de créer une nouvelle branche (sans commit) Créez simplement la nouvelle branche et les modifications y seront déplacées … les modifications du répertoire de travail n’appartiennent pas à une branche tant qu’elles ne sont pas validées (Il semblerait que les modifications sont également dans le master, mais une fois que vous avez commit les modifications, elles disparaîtront de ce dernier.) 29.7.4 Annuler la supression d’une branche Recherchez le SHA (hash) renvoyé lorsque vous avez supprimé la branche. Alors ensuite, tapez: git checkout -b &lt;branch-name&gt; &lt;SHA&gt; Voir aussi: Git undo local branch delete 29.8 Autres ressources Obtenir de l’aide Si vous êtes perdus, ce qui suit pourrait aider: GitHub Guides: Il s’agit d’une collection phénoménale de courts articles de GitHub destinés à vous aider à en apprendre davantage sur les fondamentaux de GitHub. Ils sont vraiment géniaux. Ci-dessous d’autres articles intéressants: Understanding the GitHub Flow: Explique comment fonctionne GitHub en général. Git Handbook: Explique le contrôle de version. GitHub Help: Les pages jaunes de GitHub. Vous pouvez poser une question et il essaiera de vous rediriger dans la bonne direction. Get it? Ramification GitHub est super sociable. Apprenez comment vous impliquer! Open Source Guide: Info sur comment contribuer à réaliser des projets open-source. Forking Projects: Lecture rapide de GitHub sur comment forker un repo pour pouvoir y contribuer. Mastering Issues: Sur les problèmes qu’on peut avoir en utilisant GitHub et comment ils peuvent aider à accomplir notre travail. Notre page pour contribuer: Vous pouvez contribuer à edav.info/ grâce à vos nouvelles compétences GitHub! Allez voir notre page sur comment contribuer à travers des pulls requests et autres problèmes. Ressources additionnelles Pour bien commencer, consultez GitHub Learning Lab. Cette application vous apprendra comment utiliser GitHub avec des cours pratiques utilisant des repos réels. C’est le moyen idéal pour comprendre comment utiliser GitHub. Pour les nerds dans la pièce … Git For 4 ans et plus: Il se passe beaucoup de choses sous le capot. Cette présentation aidera à expliquer comment tout cela fonctionne … avec des jouets pour enfants! Créer de jolis logs git: Rappelez-vous toujours (Un chien). De plus, cette commande d’alias est bonne à connaître: git config --global alias.adog &quot;log --all --decorate --oneline --graph&quot; add etcommit avec une commande: un autre commande d’alias utile: git config --global alias.add-commit '!git add -A &amp;&amp; git commit' Git Aware Prompt: Un excellent complément au terminal qui vous indique quelle branche vous avez consultée. Quelqu’un a également créé une version encore plus performante où il vous informera de votre statut git en utilisant des émojis utiles. Contribuer avec git2r, sur la Génétique des populations en R fournit des informations utiles sur l’utilisation des commandes git dans R par le biais du paquet git2r. En particulier, il explique comment créer un GITHUB_PAT puis définir le paramètre credential dans certaines fonctions pour trouver le PAT. (Notez cependant que le site a été créé en 2015 et qu’il n’a pas été mis à jour depuis février 2019.) Vous voulez lire un peu aussi?: Resources to learn Git est un site simple divisé en deux parties: Apprendre en lisant et apprendre en faisant. Faites votre choix. Guide du débutant pour effectuer une pull request (pour un package R), l’expérience de Tony Elhabr pour faire une pull request à un package R lors de la journée des développeurs tidyverse (élément de rstudio:: conf 2019. "],
["publish.html", "30 Publishing Resources 30.1 Vue d’ensemble 30.2 tl;dr 30.3 Bookdown 30.4 Les essentiels 30.5 Ajouter un nom de domaine personnalisé 30.6 Faire une page 404 personnalisée 30.7 Choper Travis 30.8 Notes sur notre workflow 30.9 Autres ressources", " 30 Publishing Resources 30.1 Vue d’ensemble Cette section explique comment nous avons construit edav.info/ et mentionnent des références pour construire vos propres sites et livres en utilisant R. 30.2 tl;dr Tu veux commencer à construire un site entier avec Travis CI comme celui-ci? Zach Bogard a créé [un bookdown-template] (https://github.com/zachbogart/bookdown-template){target=&quot;_blank&quot;} que tu peux cloner et travailler pour créer ton propre site. Pour plus d’information, lis le README file. 30.3 Bookdown edav.info/ a été construit à l’aide de Bookdown, un package open-source construit à partir de R Markdown afin d’écrire facilement des livres et autres longs articles. Le plus gros avantage de bookdown est qu’il nous premet de créer du contenu à la fois professionel et adaptable. Si on veut éditer un vrai livre, il faut publier une autre édition et c’est la croix et la bannière. With bookdown, on peut publier notre travail dans des formats différents (format papier inclus) et faire des moficiations facilement lorsque c’est nécessaire. Nous avons choisi bookdown pour edav.info/ parce que cela nous permet de présenter énormément de contenu d’une façon qui facilite la recherche, est compacte et permet aux étudiants de modifier ou ajouter du contenu. A nouveau, bookdown est professionel et adaptable (la version par défaut est juste un livre en ligne mais nous avons essayé de lui donner plus de vie en ajoutant beaucoup d’icônes, des logos et des bannières pour en améliorer la navigation). Ci-dessous sont mentionnées des références utiles qui ont été utilisées lors de la création d’ edav.info/. Elles peuvent être utiles pour quelqu’un qui souhaite créer son propre site internet ou une ressource en ligne pour R. 30.4 Les essentiels How to Start a Bookdown Book: Le plus dur avec bookdown est de le mettre en marche. Sean Kross propose le meilleur tutoriel que nous avons trouvés jusqu’à présent. Nous avons commencé ce projet en clonant son template repo et en le modifiant. Les descriptions sont excellentes, expliquent le rôle que joue chaque dossier et insistent sur ce qui est essentiel pour commencer un projet. bookdown: Authoring Books and Technical Documents with R Markdown: Ce livre de Yihui Xie, auteur du package bookdown, explique tout ce que bookdown est capable de faire. Une mine d’informations que nous gardons toujours à portée de main. Ce que l’auteur en dit: Un guide pour écrire des livres avec R Markdown qui inclut comment générer des graphiques et tableaux, insérer des citations, HTML widgets et applications Shiny dans R Markdown. RStudio Bookdown Talk: Yihui Xie (auteur du package bookdown) parle de son package et ce qu’il peut faire en une heure de discussion. Cette ressource est plutôt intéressante pour avoir une idée d’exemples terminées. bookdown.org: Site pour le package bookdown. Le site présente plusieurs livres populaires qui utilisent bookdown et des informations sur comment et par où commencer. Creating Websites in R: Ce tutoriel, écrit par Emily Zabor (une alumni de Columbia), explique pas-à-pas comment créer un site internet en utilisant différents outils R. L’auteur explique comment construire différents types de sites (personel, package, projet, blog) ainsi que l’intégration GitHub et comment préparer les templates et leur hosting. Cette ressource est très détaillée est vaut la peine d’être parcourue si l’on souhaite créer son propre site. 30.5 Ajouter un nom de domaine personnalisé Ajouter un nom de domaine personnalisé se fait en plusieurs parties: Acheter un nom de domaine et éditer les paramètres DNS Nous avons utilisés les domaines Google. Sur la page du registrar, cliquez sur l’icône DNS et ajoutez ceci aux Custom resource records: NAME TYPE TTL DATA @ A 1h 185.199.108.153 www CNAME 1h @ Remarquez que plusieurs tutoriels présentent des adresses IP plus vieilles. Cliquez ici pour celles qui sont le plus recommendées. Changer les paramètres de son repo Dans Settings, ajoutez votre nom de domaine personnalisée dans la section GitHub Pages. Ajoutez un CNAME file à la branche gh-pages. Il s’agit d’un file texte très simple nommé CNAME. Le content doit être une ligne avec le nom du domaine personnalisé. Pour plus de détails sur les étapes 2 et 3, voir: Emily Zabor’s Tutorial on Custom Domains 30.6 Faire une page 404 personnalisée Votre site peut être très joli mais la page 404 par défaut est toujours une déception. Lorsque quelqu’un écrit une partie de notre url de façon incorrecte ou que le lien casse, on doit s’assurer qu’il y ait quelque chose d’autres qu’une page ennuyeuse qu’on n’a pas su designer. Cet article explique le procédé en détails mais en réalité, il suffit de créer un fichier intitulé 404.html dans notre root directory et GitHub l’utilisera plutôt que la version par défaut. Pour cette raison, il n’y a vraiment aucune excuse pour ne pas en avoir un. Jetez un oeil à notre 404 page. On espère que vous ne la voyez pas trop souvent. Quelques considérations: Incluez toujours un lien vers votre site: Aide toujours le user. Expliquez clairement que quelque chose n’a pas bien fonctionné: Ne cachez pas que le fait de tomber sur cette page est une erreur. Utilisez des absolute paths: L’URL qui lance l’erreur 404 est peut-être cachée dans des dossiers inattendus. Vérifiez que si vous avez des images ou des liens, ceux-ci fonctionnent indépendemment du file path (utilisez “/images/…” rather than “images/…”, liez directement au css/page d’accueil, etc.) Et sinon, amusez-vous!: Il y a plein d’exemples de personnes qui réalisent d’excellentes pages 404. Cela devrait aider à traverser l’expérience frustrante de tomber sur une de ces pages 404. 30.7 Choper Travis Ce tutoriel est désigné pour vous aider à ajouter Travis à votre GitHub Pages créé à l’aide de bookdown. Il suppose que vous avez déjà un site internet qui fonctionne avec des pages stockées dans une branche gh-pages. Nous ne recommendons pas nécessairement la route gh-pages; Nous l’avons choisie parce que nous avons trouvé des exemples simples qui fonctionnent avec cette méthode. Comme les dossiers /docs sont une nouvelle approche ‘plus propre’, il existe très certainement une meilleure manière d’organiser le repo. Ceci dit, il y a beaucoup de tutoriels qui expliquent comment utiliser la branche gh-pages; Il s’avère que la meilleure façon de procéder est de créer une branche orpheline, comme expliqué ici. Notez également que ceci donne l’impression qu’ajouter Travis est très facile, ce qui n’est en réalité pas du tout le cas. Tout a toujours l’air facile avec du recul. Si vous avez du mal, faites-le nous savoir en loggant un problème ou en envoyant une pull request. PLus d’information sur toutes les contributions communautaires peuvent être trouvées sur notre page de contribution 30.7.1 Ajouter les fichiers de Travis au repo GitHub Ajoutez ces fichiers à votre rep: https://github.com/rstudio/bookdown-demo/blob/master/.travis.yml Pas de changements https://github.com/rstudio/bookdown-demo/blob/master/_build.sh Retire les deux dernières lignes si vous n’êtes intéressés par un livre GitHub Pages. https://github.com/rstudio/bookdown-demo/blob/master/_deploy.sh Les seuls changements que vous devez faire sont les lignes de git config. Vous devez utilisé votre adresse mail GitHub, mais le pseudonyme peut être n’importe quoi. 30.7.2 Ajouter le service de Travis Créer un compte Travis sur www.travis-ci.org en cliquant sur “Sign in with GitHub” en haut à droite. Cliquez sur Authorize pour permettre à Travis d’avoir son propre accès à GitHub. Retournez sur GitHub et créez un personal access token (PAT) si vous n’en avez pas encore un. Vous pouvez le faire ici. Notez que vous devez sauvegarder votre PAT quelque part car vous ne pourrez plus y accéder une fois qu’il est créé. Notez également que le PAT donne un moyen d’accéder votre repo GitHub via une API, ce qui est une autre façon de se connecter que via un pseudonyme/mot de passe. Retournez sur votre profil Travis (travis-ci.org/profile/[GITHUB username]) et cliquez sur le bouton à côté du repo approprié afin de le toggle. Cliquez sur Paramètres à côté du bouton et ajoutez-le à votre GITHUB_PAT sauvegardé sous les variables environementale: choisissez un “Nom” pour le “GITHUB_PAT” et une “Valeur” pour la valeur du token. Si tout s’est bien passé, vous pouvez vous relaxer et regarder Travis faire le travail à votre place. via GIPHY 30.8 Notes sur notre workflow 30.8.1 30.9 Autres ressources blogdown: Creating Websites with R Markdown: Textbook on the blogdownpackage, another option for generating websites with R. Getting Started with GitHub Pages: Short article from GitHub Guides on creating/hosting a website using GitHub Pages. A Beginner’s Guide to Travis CI for R: Fantastic blog post by Julia Silge, includes debugging advice that helped us solve a problem involving installing packages with system requirements. "],
["workflow.html", "31 Workflow Notes", " 31 Workflow Notes Le but de ce chapitre est de fournir des informations sur la maintenance de ce site Web aux research assistants, teaching assistants, etc. Familiarisez-vous avec le package bookdown. Commencez par le livre pour démarreer avec Bookdown. Comprendre le travail de contribution à EDAV avec Git. Avant de travailler sur le repo EDAV, entraînez-vous à utiliser le bookdown-practice repository. N’hésitez pas à soumettre vos pull requests à la upstream pour pratiquer. "],
["general.html", "32 Ressources générales 32.1 Livres 32.2 Cheatsheets 32.3 Articles 32.4 Meetups 32.5 Twitter 32.6 Data", " 32 Ressources générales Voici une longue liste de resources générales très utiles pour tout ce qui touche à l’exploration de données. Si vous trouvez une bonne ressource que vous ne voyez pas répertoriée ici, pensez à l’ajouter via une pulle request (voir notre page de contribution pour plus d’informations). 32.1 Livres Beaucoup de ces livres sont disponibles pour les étudiants via Columbia Libraries, en Graphical Data Analysis with R: Ce livre explique de façon systématique les différents types de données, y compris les variables catégorielles, continues et séries temporelles. L’auteur montre plusieurs exemples de techniques pour présenter les données comme ggplot et promeut le modèle “grammar of graphics”. Les parties de code sont inclues et disponibles sur le site du livre. R for Data Science: Le classique. Tout des types de données, programmation, modélisation, communication des résultats et ces raccourcis clavieres qu’on oublie tout le temps. Pour citer le livre, “Ce livre vous apprendra ) appliquer des data sciences avec R”. Tout est dit. 32.2 Cheatsheets Cheatsheet of cheatsheets: Paul van der Laken a répertorié une grande panoplie de ressources R, soit des cheatsheets, guides de style, informations sur des packages, blogs et autres ressources utiles. RStudio Cheatsheet Collection: Un ensemble de cheatsheets qui peuvent être téléchargées de RStudio. Cela inclut celles sur R Markdown, transformation de données (dplyr) et visualisation de données (ggplot2). Ils ont aussi un guide de référence R Markdown, qui est génial pour se rappeler des chunks options qu’on a tendance à oublier. R Base Graphics Cheatsheet: De façon assez suprenante, malgré sa durée d’existence, il est difficile de trouver une cheatsheet pour base graphics. Joyce a créé celle-ci pour aider ceux qui utilise cet outil. 32.3 Articles Ten Simple Rules for Better Figures: Un article utile qui explique comment faire les meilleurs graphiques en suivant des règles très simples comme “éviter le ‘chartjunk’” et “connais ton audience”. Il est bon de garder ces règles en tête. The Simpsons by the Data: Un bon exemple pour raconter une histoire avec des données (histogrammes, scatterplots, etc.). De plus, son sujet est la série télé préférée de toutes les familles (pas tout à fait vrai quand tu es français, mais on respecte la version originale en anglais). 32.4 Meetups New York Open Statistical Programming Meetup: Les meetups organisés par Jared Lander et Wes McKinney sur une variété de sujets en programmation statistique mais avec un focus sur R. Les speakers précédents étaient entre autres J.J. Allaire (créateur de RStudio) et Hadley Wickham (développeur principal de tidyverse). Les autres participants sont en génral très heureux d’accueillir de nouvelles personnes et toutes leurs séances sont disponibles sur la chaîne Youtube Lander Analytics. 32.5 Twitter R aime Twitter. Voici quelques personnes très cools qui travaillent avec #rstats: Hadley Wickham David Robinson Julia Silge 32.6 Data (Peut-être que ceci devrait être un nouveau chapitre) Membres du Congrès aux Etats-Unis (1789-Présent) avec beaucoup d’informations biographiques: "],
["chapter-index.html", "33 Chapter Index by Resource Type 33.1 Vue d’ensemble 33.2 Index", " 33 Chapter Index by Resource Type 33.1 Vue d’ensemble Cette page contient des liens vers tous les chapitres de edav.info/ Cliquez sur une bannière pour aller à la page souhaitée. Si vous vous demandez, voici une explication de la signification des couleurs des bannières. 33.2 Index "]
]
